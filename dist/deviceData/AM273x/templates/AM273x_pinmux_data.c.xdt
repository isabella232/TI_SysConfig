% var date = new Date();

/**
* Note: This file was auto-generated by TI PinMux on `date.toLocaleDateString()` at `date.toLocaleTimeString()`.
*
* \file  AM273x_pinmux_data.c
*
* \brief  This file contains the pin mux configurations for the boards.
*         These are prepared based on how the peripherals are extended on
*         the boards.
*
* \copyright Copyright (CU) `date.getFullYear()` Texas Instruments Incorporated -
*             http://www.ti.com/
*/

/* ========================================================================== */
/*                             Include Files                                  */
/* ========================================================================== */

#include "AM273x_pinmux.h"

/** Peripheral Pin Configurations */

%%{
    function capitalizeFirstLetterOnly( name ) {
        return name[0].toUpperCase() + name.substring( 1, name.length ).toLowerCase();
    };
    function getMuxMode( pin, ball) {
        var devicePin = system.deviceData.devicePins[ball];
        const muxSetting = _.find(devicePin.mux.muxSetting, (muxSetting) => muxSetting.peripheralPin.name === pin);
        return muxSetting.mode;
    };
    
%%}

%    _.each(system.modules,(mod)=> {
%        
%       //if (_.startsWith(mod),"$")))   #TODO
%
%        _.each(mod.$instances,(inst)=> {
%
%            var interfaceName = mod.displayName;
%            var peripheralName = inst.$name;
%            
static pinmuxPerCfg_t g`capitalizeFirstLetterOnly( peripheralName )`PinCfg[] =
{
%%{
            var enumStatements = [];

            const pins = _.filter(inst.peripheral, (value, key) => !_.startsWith(key,"$"));

            _.each(pins,(pin)=> {
                var pinName = pin.$solution.peripheralPinName;

                // don't try to process pins that are not selected
                if (_.isEmpty(pinName))
                    return; 

                var pull = pin.pull;
                var ballName = pin.$solution.packagePinName;
                var pad = pin.$solution.devicePinName;

                var muxMode = getMuxMode(pinName, ballName);

                var pull_enable;
                if (pull == "pd" || pull == "pu") {
                    pull_enable = "PIN_PULL_DISABLE";
                }
                else {
                    pull_enable = "~PIN_PULL_DISABLE";
                }
                
                var pull_type;
                if(pull == "pd") {
                    pull_type = "PIN_PULL_DIRECTION";
                }
                else {
                    pull_type = "~PIN_PULL_DIRECTION"
                }
                
                    enumStatements.push(
                    {
                        line1 : "/* " + inst.peripheral.$name + " -> " + pinName + " -> " + ballName + " */",
                        line2 : "{",
                        line3 : "    CSL_MSS_IOMUX_" + pad.replace("_","") + "_CFG_REG" + ", " + "PIN_MODE(" + muxMode + ") | \\",
                        line4 : "    (" + (pull_enable) + ") & (" + (pull_type) + ")",
                        line5 : "},"
                    });
            });
%%}
% for( var i = 0; i < enumStatements.length; ++i ) {
    `enumStatements[i].line1`
    `enumStatements[i].line2`
    `enumStatements[i].line3`
    `enumStatements[i].line4`
    `enumStatements[i].line5`
%           }
    {PINMUX_END}
};
 %});
static pinmuxModuleCfg_t g`capitalizeFirstLetterOnly( mod.displayName )`PinCfg[] =
{
% _.each(mod.$instances,(inst)=> {
    { `parseInt( inst.$name.replace('AM273x', '').replace(mod.displayName, '').replace(/[^0-9\.]/g, ''), 10 )`, TRUE, g`capitalizeFirstLetterOnly( inst.$name )`PinCfg},
% });
    {PINMUX_END}
};
       
%});

%%{
var enumSet = [];
_.each(system.modules,(mod)=> {
    enumSet.push("g" + capitalizeFirstLetterOnly( mod.displayName ) + "PinCfg");
});
%%}
pinmuxBoardCfg_t gAM273xPinmuxData[] =
{
%   for( var i = 0; i < enumSet.length; ++i ) {
    {`i`, `enumSet[i]`},
%   }
    {PINMUX_END}
};
