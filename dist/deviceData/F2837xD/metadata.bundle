defineResource("/F2837xD/templates/bitfield/f2837xd_pinmux.c.xdt", function(_, system, pmux, scripting, require) { "use strict";return function(args) {
var __t, __p = '', __j = Array.prototype.join;
function print() { __p += __j.call(arguments, '') }

 var $legacy = pmux.getScript("/legacy/adapt.js")(pmux), assignmentErrors = $legacy.assignmentErrors, assignments = $legacy.assignments, peripheralConfigurables = $legacy.peripheralConfigurables, peripheralConfigurations = $legacy.peripheralConfigurations, selectedUseCases = $legacy.selectedUseCases, version = $legacy.version, deviceData = $legacy.deviceData;

    var date = new Date();

    var maxGpioNumber = _.chain( deviceData.devicePins )
        .map( "designSignalName" )
        .map( function( name ) { return parseInt( name.substr( 4 ) ); } )
        .max()
        .value()

    var maxPortIndex = Math.floor( parseInt( maxGpioNumber ) / 32 );

    var portIndices = _.take( [ "A", "B", "C", "D", "E", "F" ], maxPortIndex + 1 );

    // Make sure we don't get any writes to a MUX2 reg that doesn't exist
    var needMUX2ForLastPort = true;
    if( (maxGpioNumber % 32) < 16 ) {
        needMUX2ForLastPort = false;
    }

    var xbarPresent = [];
    _.times( 16, function() {
        xbarPresent.push( false );
    } );

    _.each( assignments, function( assignment ) {
        if (/XBAR/.test(assignment.muxMode) == true) {
            xbarPresent[parseInt( assignment.muxMode.substr( 4 ) ) - 1] = true;
        }
    } );

;
__p += '//*****************************************************************************\n//\n// f2837xd_pinmux.c - Function to write the generated pin mux values to the\n//                    appropriate registers.\n// Created using TI Pinmux ' +
((__t = (version)) == null ? '' : __t) +
' on ' +
((__t = (date.toLocaleDateString())) == null ? '' : __t) +
' at ' +
((__t = (date.toLocaleTimeString())) == null ? '' : __t) +
'.\n//\n//*****************************************************************************\n//\n// Copyright (C) 2017 Texas Instruments Incorporated - http://www.ti.com/\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions\n// are met:\n//\n//   Redistributions of source code must retain the above copyright\n//   notice, this list of conditions and the following disclaimer.\n//\n//   Redistributions in binary form must reproduce the above copyright\n//   notice, this list of conditions and the following disclaimer in the\n//   documentation and/or other materials provided with the\n//   distribution.\n//\n//   Neither the name of Texas Instruments Incorporated nor the names of\n//   its contributors may be used to endorse or promote products derived\n//   from this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//\n//*****************************************************************************\n//\n// NOTE!! This file uses bit field structures and macros from C2000Ware.\n// This function is provided for your convenience and to serve as an example\n// of the use of the generated header file, but its use is not required.\n//\n// To download C2000Ware:  http://www.ti.com/tool/C2000Ware\n//\n//*****************************************************************************\n\n#include "F28x_Project.h"\n#include "f2837xd_pinmux.h"\n\n//*****************************************************************************\n//\n// Configures the pin mux registers, using the generated register values.\n//\n// This function writes the values generated by the pin mux tool to their\n// corresponding GPIO control registers. These generated values should be found\n// in the generated "f2837xd_pinmux.h."\n//\n//*****************************************************************************\nvoid\nGPIO_setPinMuxConfig(void)\n{\n';
 _.each( portIndices, function( port ) {
;
__p += '    Uint32 lockVal' +
((__t = (port)) == null ? '' : __t) +
';\n';
 } )
;
__p += '\n    EALLOW;\n\n    //\n    // Save the current value of the GPIO lock registers\n    //\n';
 _.each( portIndices, function( port ) {
;
__p += '    lockVal' +
((__t = (port)) == null ? '' : __t) +
' = GpioCtrlRegs.GP' +
((__t = (port)) == null ? '' : __t) +
'LOCK.all;\n';
 } )
;
__p += '\n    //\n    // Unlock the GPIO control registers\n    //\n';
 _.each( portIndices, function( port ) {
;
__p += '    GpioCtrlRegs.GP' +
((__t = (port)) == null ? '' : __t) +
'LOCK.all = 0x00000000;\n';
 } )
;
__p += '\n    //\n    // Clear the mux register fields that are about to be changed\n    //\n';
 _.each( portIndices, function( port ) {
;
__p += '    GpioCtrlRegs.GP' +
((__t = (port)) == null ? '' : __t) +
'GMUX1.all	&= ~GP' +
((__t = (port)) == null ? '' : __t) +
'MUX1_MASK;\n';
   if( (needMUX2ForLastPort == true) || (port != (portIndices[maxPortIndex])) ) {
;
__p += '    GpioCtrlRegs.GP' +
((__t = (port)) == null ? '' : __t) +
'GMUX2.all	&= ~GP' +
((__t = (port)) == null ? '' : __t) +
'MUX2_MASK;\n';
   }
;
__p += '    GpioCtrlRegs.GP' +
((__t = (port)) == null ? '' : __t) +
'MUX1.all	&= ~GP' +
((__t = (port)) == null ? '' : __t) +
'MUX1_MASK;\n';
   if( (needMUX2ForLastPort == true) || (port != (portIndices[maxPortIndex])) ) {
;
__p += '    GpioCtrlRegs.GP' +
((__t = (port)) == null ? '' : __t) +
'MUX2.all	&= ~GP' +
((__t = (port)) == null ? '' : __t) +
'MUX2_MASK;\n';
   }
 } )
;
__p += '\n    //\n    // Write pin muxing to mux registers\n    //\n';
 _.each( portIndices, function( port ) {
;
__p += '    GpioCtrlRegs.GP' +
((__t = (port)) == null ? '' : __t) +
'GMUX1.all	|=  GP' +
((__t = (port)) == null ? '' : __t) +
'GMUX1_VALUE;\n';
   if( (needMUX2ForLastPort == true) || (port != (portIndices[maxPortIndex])) ) {
;
__p += '    GpioCtrlRegs.GP' +
((__t = (port)) == null ? '' : __t) +
'GMUX2.all	|=  GP' +
((__t = (port)) == null ? '' : __t) +
'GMUX2_VALUE;\n';
   }
;
__p += '    GpioCtrlRegs.GP' +
((__t = (port)) == null ? '' : __t) +
'MUX1.all	|=  GP' +
((__t = (port)) == null ? '' : __t) +
'MUX1_VALUE;\n';
   if( (needMUX2ForLastPort == true) || (port != (portIndices[maxPortIndex])) ) {
;
__p += '    GpioCtrlRegs.GP' +
((__t = (port)) == null ? '' : __t) +
'MUX2.all	|=  GP' +
((__t = (port)) == null ? '' : __t) +
'MUX2_VALUE;\n';
   }
 } )
;
__p += '\n    //\n    // Write pin analog mode select to registers\n    //\n';
   // Currently only supporting configuration of GPBAMSEL hence the lack of .each here
;
__p += '    GpioCtrlRegs.GPBAMSEL.all	&= ~GPBAMSEL_MASK;\n    GpioCtrlRegs.GPBAMSEL.all	|= GPBAMSEL_VALUE;\n\n';
 if( _.includes( xbarPresent, true) ) {
;
__p += '    //\n    // Write Input X-BAR pin selection to registers\n    //\n';
   for( var xbarIndex = 0; xbarIndex < xbarPresent.length; ++xbarIndex ) {
       if(xbarPresent[xbarIndex] == true) {
;
__p += '    InputXbarRegs.INPUT' +
((__t = ((xbarIndex + 1))) == null ? '' : __t) +
'SELECT	= INPUT' +
((__t = ((xbarIndex + 1))) == null ? '' : __t) +
'SELECT_VALUE;\n';
       }
   }
;
__p += '\n';
 }
;
__p += '    //\n    // Restore GPIO lock register values\n    //\n';
 _.each( portIndices, function( port ) {
;
__p += '    GpioCtrlRegs.GP' +
((__t = (port)) == null ? '' : __t) +
'LOCK.all = lockVal' +
((__t = (port)) == null ? '' : __t) +
';\n';
 } )
;
__p += '\n    EDIS;\n}\n';
return __p
}; });
defineResource("/F2837xD/templates/bitfield/f2837xd_pinmux.h.xdt", function(_, system, pmux, scripting, require) { "use strict";return function(args) {
var __t, __p = '', __j = Array.prototype.join;
function print() { __p += __j.call(arguments, '') }

 var $legacy = pmux.getScript("/legacy/adapt.js")(pmux), assignmentErrors = $legacy.assignmentErrors, assignments = $legacy.assignments, peripheralConfigurables = $legacy.peripheralConfigurables, peripheralConfigurations = $legacy.peripheralConfigurations, selectedUseCases = $legacy.selectedUseCases, version = $legacy.version, deviceData = $legacy.deviceData;

    var date = new Date();

    var maxGpioNumber = _.chain( deviceData.devicePins )
        .map( "designSignalName" )
        .map( function( name ) { return parseInt( name.substr( 4 ) ); } )
        .max()
        .value()

    var maxPortIndex = Math.floor( parseInt( maxGpioNumber ) / 32 );

    var possibleIndices = [ "A", "B", "C", "D", "E", "F", "G", "H" ];
    var portIndices = _.take( possibleIndices, maxPortIndex + 1 );

    // Make sure we don't get any defines for a MUX2 reg that doesn't exist
    var needMUX2ForLastPort = true;
    if( (maxGpioNumber % 32) < 16 ) {
        needMUX2ForLastPort = false;
    }

    // Variables for normal GPIO
    var muxValues = [];
    var comments = [];
    var muxMasks = [];

    _.times( portIndices.length, function() {
        muxValues.push( [ [ 0, 0 ], [ 0, 0 ] ] );
        comments.push( [] );
        muxMasks.push( [ 0, 0 ] );
    } );

    // Variables for AMSEL
    var amselValues = [];
    var amselComments = [];
    var amselMasks = [];

    _.times( possibleIndices.length, function() {
        amselValues.push( [] );
        amselComments.push( [] );
        amselMasks.push( [] );
    } );

    // Variables for Input X-BAR
    var xbarValues = [];
    var xbarComments = [];
    var xbarPresent = false;

    _.times( 16, function() {
        xbarValues.push( null );
        xbarComments.push( null );
    } );

    // Loop through all assignments made by the solver
    _.each( assignments, function( assignment ) {

        if (assignment.muxMode == "ALT") {

            //////////////// Procedure for handling USB ////////////////
            if (/USB/.test(assignment.peripheralPin.name) == true) {

                // Extract the GPIO number for the pin that was chosen
                var gpioNumber = parseInt( assignment.devicePin.designSignalName.substr( 4 ) );

                var portIndex = Math.floor( gpioNumber / 32 );
                var shiftAmount = gpioNumber % 32;

                amselValues[ portIndex ] = ( amselValues[ portIndex ] | ( 1 << shiftAmount ) ) >>> 0;

                amselComments[ portIndex ].push( "// Pin " + assignment.devicePin.ball + " " +
                    "(" + assignment.devicePin.designSignalName + ") " +
                    "to " + assignment.peripheralPin.name + " " +
                    "(mode " + assignment.muxMode + ")" );

                amselMasks[ portIndex ] = ( amselMasks[ portIndex ] | ( 0x1 << shiftAmount ) ) >>> 0;
            }
        } else if (/XBAR/.test(assignment.muxMode) == true) {
            //////////////// Procedure for handling Input XBAR ////////////////

            xbarPresent = true;

            // Extract the GPIO number for the pin that was chosen
            var gpioNumber = parseInt( assignment.devicePin.designSignalName.substr( 4 ) );
            var xbarNumber = parseInt( assignment.muxMode.substr( 4 ) ) - 1;

            xbarValues[ xbarNumber ] = gpioNumber;

            xbarComments[ xbarNumber ] = "// Pin " + assignment.devicePin.ball + " " +
                "(" + assignment.devicePin.designSignalName + ") " +
                "to " + assignment.peripheralPin.name + " " +
                "(mode " + assignment.muxMode + ")";

        } else {
            //////////////// Procedure for handling normal GPIO ////////////////

            // Extract the GPIO number for the pin that was chosen
            var gpioNumber = parseInt( assignment.devicePin.designSignalName.substr( 4 ) );

            // Calculate which port the GPIO is on
            var portIndex = Math.floor( gpioNumber / 32 );

            // Calculate the shift amount to get the mux mode value into the right
            // field in the register. Remember there are 16 GPIOs per register and
            // they each get two bits.
            var shiftAmount = (gpioNumber % 16) * 2;

            // Is the GPIO configured in MUX1 or MUX2?
            var regNumber = ( ( gpioNumber % 32 ) < 16 ) ? 0 : 1;

            // Calculate value for the GPn(G)MUX#_VALUE #defines.
            // Lower 2 bits are in GPnMUX#_VALUE, upper two are in GPnGMUX#_VALUE
            // Shift each GPIO's mux mode value into place and OR it in.
            muxValues[ portIndex ][ regNumber ][ 0 ] = ( muxValues[ portIndex ][ regNumber ][ 0 ] | ( ( assignment.muxMode & 0x3 ) << shiftAmount ) ) >>> 0;
            muxValues[ portIndex ][ regNumber ][ 1 ] = ( muxValues[ portIndex ][ regNumber ][ 1 ] | ( ( assignment.muxMode >> 2 ) << shiftAmount ) ) >>> 0;
            comments[ portIndex ].push( "// Pin " + assignment.devicePin.ball + " " +
                "(" + assignment.devicePin.designSignalName + ") " +
                "to " + assignment.peripheralPin.name + " " +
                "(mode " + assignment.muxMode + ")" );
            muxMasks[ portIndex ][ regNumber ] = ( muxMasks[ portIndex ][ regNumber ] | ( 0x3 << shiftAmount ) ) >>> 0;

            if ((gpioNumber == 42) || (gpioNumber == 43)) {
                // Make sure the AMSEL bit is cleared when 42 and 43 are not being used for USB
                var shiftAmount = gpioNumber % 32;

                amselComments[ portIndex ].push( "// Pin " + assignment.devicePin.ball + " " +
                    "(" + assignment.devicePin.designSignalName + ") " +
                    "to " + assignment.peripheralPin.name + " " +
                    "(mode " + assignment.muxMode + ")" );

                amselMasks[ portIndex ] = ( amselMasks[ portIndex ] | ( 0x1 << shiftAmount ) ) >>> 0;
            }

        }
    } );

    var toPaddedHex = function( value ) {
        var unPadded = ( value ).toString( 16 );
        var passing = "0x00000000";
        return passing.substr( 0, passing.length - unPadded.length ) + unPadded;
    };

    var poundDefineMask = function( portIndex, registerIndex ) {
        return "GP" + portIndices[ portIndex ] + "MUX" + ( registerIndex + 1 ) + "_MASK";
    };

    var poundDefineName = function( portIndex, registerIndex, isGroup ) {
        return "GP" + portIndices[ portIndex ] + ( ( isGroup === 1 ) ? "G" : "" ) +
            "MUX" + ( registerIndex + 1 ) + "_VALUE";
    };

    var amselPoundDefineName = function( portIndex ) {
        return "GP" + possibleIndices[ portIndex ] + "AMSEL_VALUE";
    };

    var amselPoundDefineMask = function( portIndex ) {
        return "GP" + possibleIndices[ portIndex ] + "AMSEL_MASK";
    };

    var xbarPoundDefineName = function( xbarNumber ) {
        return "INPUT" + (xbarNumber + 1) + "SELECT_VALUE";
    };

;
__p += '//*****************************************************************************\n//\n//  f2837xd_pinmux.h - Created using TI Pinmux ' +
((__t = (version)) == null ? '' : __t) +
' on ' +
((__t = (date.toLocaleDateString())) == null ? '' : __t) +
' at ' +
((__t = (date.toLocaleTimeString())) == null ? '' : __t) +
'.\n//\n//*****************************************************************************\n//\n// Copyright (C) 2017 Texas Instruments Incorporated - http://www.ti.com/\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions\n// are met:\n//\n//   Redistributions of source code must retain the above copyright\n//   notice, this list of conditions and the following disclaimer.\n//\n//   Redistributions in binary form must reproduce the above copyright\n//   notice, this list of conditions and the following disclaimer in the\n//   documentation and/or other materials provided with the\n//   distribution.\n//\n//   Neither the name of Texas Instruments Incorporated nor the names of\n//   its contributors may be used to endorse or promote products derived\n//   from this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//\n//*****************************************************************************\n//\n//  These values will provide the functionality requested when written into\n//  the registers for which the #defines are named.  For example, using the\n//  C2000Ware device support header files, use the defines like in this\n//  sample function:\n//\n//  void samplePinMuxFxn(void)\n//  {\n//      EALLOW;\n//      //\n//      // Write generated values to mux registers\n//      //\n//      GpioCtrlRegs.GPAMUX1.all  = GPAMUX1_VALUE;\n//      GpioCtrlRegs.GPAMUX2.all  = GPAMUX2_VALUE;\n//      GpioCtrlRegs.GPBMUX1.all  = GPBMUX1_VALUE;\n//        . . .\n//      EDIS;\n//  }\n//\n//  NOTE:  These GPIO control registers are only available on CPU1.\n//\n//*****************************************************************************\n';
 for( var portIndex = 0; portIndex < portIndices.length; ++portIndex ) {
;
__p += '\n//\n// Port ' +
((__t = (portIndices[ portIndex ])) == null ? '' : __t) +
' mux register values\n//\n';
   _.each( comments[ portIndex ], function( comment ) {
;
__p +=
((__t = (comment)) == null ? '' : __t) +
'\n';
   } );
;
__p += '#define ' +
((__t = (poundDefineMask( portIndex, 0 ))) == null ? '' : __t) +
'		' +
((__t = (toPaddedHex( muxMasks[ portIndex ][ 0 ] ))) == null ? '' : __t) +
'\n';
   if( (needMUX2ForLastPort == true) || (portIndex != maxPortIndex) ) {
;
__p += '#define ' +
((__t = (poundDefineMask( portIndex, 1 ))) == null ? '' : __t) +
'		' +
((__t = (toPaddedHex( muxMasks[ portIndex ][ 1 ] ))) == null ? '' : __t) +
'\n';
   }
;
__p += '#define ' +
((__t = (poundDefineName( portIndex, 0, 0 ))) == null ? '' : __t) +
'		' +
((__t = (toPaddedHex( muxValues[ portIndex ][ 0 ][ 0 ] ))) == null ? '' : __t) +
'\n';
   if( (needMUX2ForLastPort == true) || (portIndex != maxPortIndex) ) {
;
__p += '#define ' +
((__t = (poundDefineName( portIndex, 1, 0 ))) == null ? '' : __t) +
'		' +
((__t = (toPaddedHex( muxValues[ portIndex ][ 1 ][ 0 ] ))) == null ? '' : __t) +
'\n';
   }
;
__p += '#define ' +
((__t = (poundDefineName( portIndex, 0, 1 ))) == null ? '' : __t) +
'		' +
((__t = (toPaddedHex( muxValues[ portIndex ][ 0 ][ 1 ] ))) == null ? '' : __t) +
'\n';
   if( (needMUX2ForLastPort == true) || (portIndex != maxPortIndex) ) {
;
__p += '#define ' +
((__t = (poundDefineName( portIndex, 1, 1 ))) == null ? '' : __t) +
'		' +
((__t = (toPaddedHex( muxValues[ portIndex ][ 1 ][ 1 ] ))) == null ? '' : __t) +
'\n';
   }
 }
;
__p += '\n';
 for( var portIndex = 0; portIndex < possibleIndices.length; ++portIndex ) {
   // Currently only supporting configuration of GPBAMSEL hence the "portIndex == 1" below
   if((portIndex == 1)) {
;
__p += '//\n// Port ' +
((__t = (possibleIndices[ portIndex ])) == null ? '' : __t) +
' analog mode register values\n//\n';
       _.each( amselComments[ portIndex ], function( comment ) {
;
__p +=
((__t = (comment)) == null ? '' : __t) +
'\n';
       } );
;
__p += '#define ' +
((__t = (amselPoundDefineMask( portIndex ))) == null ? '' : __t) +
'		' +
((__t = (toPaddedHex( amselMasks[ portIndex ] ))) == null ? '' : __t) +
'\n#define ' +
((__t = (amselPoundDefineName( portIndex ))) == null ? '' : __t) +
'		' +
((__t = (toPaddedHex( amselValues[ portIndex ] ))) == null ? '' : __t) +
'\n';
   }
 }
;
__p += '\n';
 if(xbarPresent == true) {
;
__p += '//\n// Input X-BAR register values\n//\n';
   for( var xbarIndex = 0; xbarIndex < xbarValues.length; ++xbarIndex ) {
       if((xbarComments[xbarIndex] != null)) {
;
__p +=
((__t = (xbarComments[ xbarIndex ])) == null ? '' : __t) +
'\n';
       }
   }
   for( var xbarIndex = 0; xbarIndex < xbarValues.length; ++xbarIndex ) {
       if((xbarValues[xbarIndex] != null)) {
;
__p += '#define ' +
((__t = (xbarPoundDefineName( xbarIndex ))) == null ? '' : __t) +
'	' +
((__t = (toPaddedHex( xbarValues[ xbarIndex ] ))) == null ? '' : __t) +
'\n';
       }
   }
;
__p += '\n';
 }
;
__p += '//*****************************************************************************\n//\n// Function prototype for function to write values above into their\n// corresponding registers. This function is found in f2837xd_pinmux.c. Its use\n// is completely optional.\n//\n//*****************************************************************************\nextern void GPIO_setPinMuxConfig(void);\n';
return __p
}; });
defineResource("/F2837xD/templates/csv/PinmuxConfigSummary.csv.xdt", function(_, system, pmux, scripting, require) { "use strict";return function(args) {
var __t, __p = '', __j = Array.prototype.join;
function print() { __p += __j.call(arguments, '') }

 var $legacy = pmux.getScript("/legacy/adapt.js")(pmux), assignmentErrors = $legacy.assignmentErrors, assignments = $legacy.assignments, peripheralConfigurables = $legacy.peripheralConfigurables, peripheralConfigurations = $legacy.peripheralConfigurations, selectedUseCases = $legacy.selectedUseCases, version = $legacy.version, deviceData = $legacy.deviceData;
;
__p += 'Design Signal Pad Name,Ball Name,Selected Mode Number,Mode Interface Name,Mode Signal Name,User Requirement Name\n';
 for( var i = 0; i < assignments.length; ++i ) {
;
__p +=
((__t = (assignments[i].devicePin.designSignalName)) == null ? '' : __t) +
',' +
((__t = (assignments[i].devicePin.ball)) == null ? '' : __t) +
',' +
((__t = (assignments[i].muxMode)) == null ? '' : __t) +
',' +
((__t = (assignments[i].peripheral.name)) == null ? '' : __t) +
',' +
((__t = (assignments[i].peripheralPin.name)) == null ? '' : __t) +
',' +
((__t = (assignments[i].requirementName)) == null ? '' : __t) +
'\n';
 }
;

return __p
}; });
defineResource("/F2837xD/templates/driverlib/pinmux.c.xdt", function(_, system, pmux, scripting, require) { "use strict";return function(args) {
var __t, __p = '', __j = Array.prototype.join;
function print() { __p += __j.call(arguments, '') }

 var $legacy = pmux.getScript("/legacy/adapt.js")(pmux), assignmentErrors = $legacy.assignmentErrors, assignments = $legacy.assignments, peripheralConfigurables = $legacy.peripheralConfigurables, peripheralConfigurations = $legacy.peripheralConfigurations, selectedUseCases = $legacy.selectedUseCases, version = $legacy.version, deviceData = $legacy.deviceData;

    var date = new Date();

    var maxGpioNumber = _.chain( deviceData.devicePins )
        .map( "designSignalName" )
        .map( function( name ) { return parseInt( name.substr( 4 ) ); } )
        .max()
        .value()

    var maxPortIndex = Math.floor( parseInt( maxGpioNumber ) / 32 );

    var portIndices = _.take( [ "A", "B", "C", "D", "E", "F" ], maxPortIndex + 1 );

    // Make sure we don't get any writes to a MUX2 reg that doesn't exist
    var needMUX2ForLastPort = true;
    if( (maxGpioNumber % 32) < 16 ) {
        needMUX2ForLastPort = false;
    }

    var xbarPresent = [];
    _.times( 16, function() {
        xbarPresent.push( false );
    } );

    _.each( assignments, function( assignment ) {
        if (/XBAR/.test(assignment.muxMode) == true) {
            xbarPresent[parseInt( assignment.muxMode.substr( 4 ) ) - 1] = true;
        }
    } );

;
__p += '//*****************************************************************************\n//\n// pinmux.c - Function to write the generated pin mux values to the appropriate\n//            registers.\n// Created using TI Pinmux ' +
((__t = (version)) == null ? '' : __t) +
' on ' +
((__t = (date.toLocaleDateString())) == null ? '' : __t) +
' at ' +
((__t = (date.toLocaleTimeString())) == null ? '' : __t) +
'.\n//\n//*****************************************************************************\n//\n// Copyright (C) 2017 Texas Instruments Incorporated - http://www.ti.com/\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions\n// are met:\n//\n//   Redistributions of source code must retain the above copyright\n//   notice, this list of conditions and the following disclaimer.\n//\n//   Redistributions in binary form must reproduce the above copyright\n//   notice, this list of conditions and the following disclaimer in the\n//   documentation and/or other materials provided with the\n//   distribution.\n//\n//   Neither the name of Texas Instruments Incorporated nor the names of\n//   its contributors may be used to endorse or promote products derived\n//   from this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//\n//*****************************************************************************\n//\n// NOTE!! This file uses driverlib register macros from C2000Ware.\n// This function is provided for your convenience and to serve as an example\n// of the use of the generated header file, but its use is not required.\n//\n// To download C2000Ware:  http://www.ti.com/tool/C2000Ware\n//\n//*****************************************************************************\n\n#include "driverlib.h"\n#include "pinmux.h"\n\n//*****************************************************************************\n//\n// Configures the pin mux registers, using the generated register values.\n//\n// This function writes the values generated by the pin mux tool to their\n// corresponding GPIO control registers. These generated values should be found\n// in the generated "pinmux.h."\n//\n//*****************************************************************************\nvoid\nGPIO_setPinMuxConfig(void)\n{\n';
 _.each( portIndices, function( port ) {
;
__p += '    uint32_t lockVal' +
((__t = (port)) == null ? '' : __t) +
';\n';
 } )
;
__p += '\n    EALLOW;\n\n    //\n    // Save the current value of the GPIO lock registers\n    //\n';
 _.each( portIndices, function( port ) {
;
__p += '    lockVal' +
((__t = (port)) == null ? '' : __t) +
' = HWREG(GPIOCTRL_BASE + GPIO_O_GP' +
((__t = (port)) == null ? '' : __t) +
'LOCK);\n';
 } )
;
__p += '\n    //\n    // Unlock the GPIO control registers\n    //\n';
 _.each( portIndices, function( port ) {
;
__p += '    HWREG(GPIOCTRL_BASE + GPIO_O_GP' +
((__t = (port)) == null ? '' : __t) +
'LOCK) = 0x00000000;\n';
 } )
;
__p += '\n    //\n    // Clear the mux register fields that are about to be changed\n    //\n';
 _.each( portIndices, function( port ) {
;
__p += '    HWREG(GPIOCTRL_BASE + GPIO_O_GP' +
((__t = (port)) == null ? '' : __t) +
'GMUX1)	&= ~GP' +
((__t = (port)) == null ? '' : __t) +
'MUX1_MASK;\n';
   if( (needMUX2ForLastPort == true) || (port != (portIndices[maxPortIndex])) ) {
;
__p += '    HWREG(GPIOCTRL_BASE + GPIO_O_GP' +
((__t = (port)) == null ? '' : __t) +
'GMUX2)	&= ~GP' +
((__t = (port)) == null ? '' : __t) +
'MUX2_MASK;\n';
   }
;
__p += '    HWREG(GPIOCTRL_BASE + GPIO_O_GP' +
((__t = (port)) == null ? '' : __t) +
'MUX1)	&= ~GP' +
((__t = (port)) == null ? '' : __t) +
'MUX1_MASK;\n';
   if( (needMUX2ForLastPort == true) || (port != (portIndices[maxPortIndex])) ) {
;
__p += '    HWREG(GPIOCTRL_BASE + GPIO_O_GP' +
((__t = (port)) == null ? '' : __t) +
'MUX2)	&= ~GP' +
((__t = (port)) == null ? '' : __t) +
'MUX2_MASK;\n';
   }
 } )
;
__p += '\n    //\n    // Write pin muxing to mux registers\n    //\n';
 _.each( portIndices, function( port ) {
;
__p += '    HWREG(GPIOCTRL_BASE + GPIO_O_GP' +
((__t = (port)) == null ? '' : __t) +
'GMUX1)	|=  GP' +
((__t = (port)) == null ? '' : __t) +
'GMUX1_VALUE;\n';
   if( (needMUX2ForLastPort == true) || (port != (portIndices[maxPortIndex])) ) {
;
__p += '    HWREG(GPIOCTRL_BASE + GPIO_O_GP' +
((__t = (port)) == null ? '' : __t) +
'GMUX2)	|=  GP' +
((__t = (port)) == null ? '' : __t) +
'GMUX2_VALUE;\n';
   }
;
__p += '    HWREG(GPIOCTRL_BASE + GPIO_O_GP' +
((__t = (port)) == null ? '' : __t) +
'MUX1)	|=  GP' +
((__t = (port)) == null ? '' : __t) +
'MUX1_VALUE;\n';
   if( (needMUX2ForLastPort == true) || (port != (portIndices[maxPortIndex])) ) {
;
__p += '    HWREG(GPIOCTRL_BASE + GPIO_O_GP' +
((__t = (port)) == null ? '' : __t) +
'MUX2)	|=  GP' +
((__t = (port)) == null ? '' : __t) +
'MUX2_VALUE;\n';
   }
 } )
;
__p += '\n    //\n    // Write pin analog mode select to registers\n    //\n';
   // Currently only supporting configuration of GPBAMSEL hence the lack of .each here
;
__p += '    HWREG(GPIOCTRL_BASE + GPIO_O_GPBAMSEL)	&= ~GPBAMSEL_MASK;\n    HWREG(GPIOCTRL_BASE + GPIO_O_GPBAMSEL)	|= GPBAMSEL_VALUE;\n\n';
 if( _.includes( xbarPresent, true) ) {
;
__p += '    //\n    // Write Input X-BAR pin selection to registers\n    //\n';
   for( var xbarIndex = 0; xbarIndex < xbarPresent.length; ++xbarIndex ) {
       if(xbarPresent[xbarIndex] == true) {
;
__p += '    HWREGH(XBAR_INPUT_BASE + XBAR_O_INPUT' +
((__t = ((xbarIndex + 1))) == null ? '' : __t) +
'SELECT)	= INPUT' +
((__t = ((xbarIndex + 1))) == null ? '' : __t) +
'SELECT_VALUE;\n';
       }
   }
;
__p += '\n';
 }
;
__p += '    //\n    // Restore GPIO lock register values\n    //\n';
 _.each( portIndices, function( port ) {
;
__p += '    HWREG(GPIOCTRL_BASE + GPIO_O_GP' +
((__t = (port)) == null ? '' : __t) +
'LOCK) = lockVal' +
((__t = (port)) == null ? '' : __t) +
';\n';
 } )
;
__p += '\n    EDIS;\n}\n';
return __p
}; });
defineResource("/F2837xD/templates/driverlib/pinmux.h.xdt", function(_, system, pmux, scripting, require) { "use strict";return function(args) {
var __t, __p = '', __j = Array.prototype.join;
function print() { __p += __j.call(arguments, '') }

 var $legacy = pmux.getScript("/legacy/adapt.js")(pmux), assignmentErrors = $legacy.assignmentErrors, assignments = $legacy.assignments, peripheralConfigurables = $legacy.peripheralConfigurables, peripheralConfigurations = $legacy.peripheralConfigurations, selectedUseCases = $legacy.selectedUseCases, version = $legacy.version, deviceData = $legacy.deviceData;

    var date = new Date();

    var maxGpioNumber = _.chain( deviceData.devicePins )
        .map( "designSignalName" )
        .map( function( name ) { return parseInt( name.substr( 4 ) ); } )
        .max()
        .value()

    var maxPortIndex = Math.floor( parseInt( maxGpioNumber ) / 32 );

    var possibleIndices = [ "A", "B", "C", "D", "E", "F", "G", "H" ];
    var portIndices = _.take( possibleIndices, maxPortIndex + 1 );

    // Make sure we don't get any defines for a MUX2 reg that doesn't exist
    var needMUX2ForLastPort = true;
    if( (maxGpioNumber % 32) < 16 ) {
        needMUX2ForLastPort = false;
    }

    // Variables for normal GPIO
    var muxValues = [];
    var comments = [];
    var muxMasks = [];

    _.times( portIndices.length, function() {
        muxValues.push( [ [ 0, 0 ], [ 0, 0 ] ] );
        comments.push( [] );
        muxMasks.push( [ 0, 0 ] );
    } );

    // Variables for AMSEL
    var amselValues = [];
    var amselComments = [];
    var amselMasks = [];

    _.times( possibleIndices.length, function() {
        amselValues.push( [] );
        amselComments.push( [] );
        amselMasks.push( [] );
    } );

    // Variables for Input X-BAR
    var xbarValues = [];
    var xbarComments = [];
    var xbarPresent = false;

    _.times( 16, function() {
        xbarValues.push( null );
        xbarComments.push( null );
    } );

    // Loop through all assignments made by the solver
    _.each( assignments, function( assignment ) {

        if (assignment.muxMode == "ALT") {

            //////////////// Procedure for handling USB ////////////////
            if (/USB/.test(assignment.peripheralPin.name) == true) {

                // Extract the GPIO number for the pin that was chosen
                var gpioNumber = parseInt( assignment.devicePin.designSignalName.substr( 4 ) );

                var portIndex = Math.floor( gpioNumber / 32 );
                var shiftAmount = gpioNumber % 32;

                amselValues[ portIndex ] = ( amselValues[ portIndex ] | ( 1 << shiftAmount ) ) >>> 0;

                amselComments[ portIndex ].push( "// Pin " + assignment.devicePin.ball + " " +
                    "(" + assignment.devicePin.designSignalName + ") " +
                    "to " + assignment.peripheralPin.name + " " +
                    "(mode " + assignment.muxMode + ")" );

                amselMasks[ portIndex ] = ( amselMasks[ portIndex ] | ( 0x1 << shiftAmount ) ) >>> 0;
            }
        } else if (/XBAR/.test(assignment.muxMode) == true) {
            //////////////// Procedure for handling Input XBAR ////////////////

            xbarPresent = true;

            // Extract the GPIO number for the pin that was chosen
            var gpioNumber = parseInt( assignment.devicePin.designSignalName.substr( 4 ) );
            var xbarNumber = parseInt( assignment.muxMode.substr( 4 ) ) - 1;

            xbarValues[ xbarNumber ] = gpioNumber;

            xbarComments[ xbarNumber ] = "// Pin " + assignment.devicePin.ball + " " +
                "(" + assignment.devicePin.designSignalName + ") " +
                "to " + assignment.peripheralPin.name + " " +
                "(mode " + assignment.muxMode + ")";

        } else {
            //////////////// Procedure for handling normal GPIO ////////////////

            // Extract the GPIO number for the pin that was chosen
            var gpioNumber = parseInt( assignment.devicePin.designSignalName.substr( 4 ) );

            // Calculate which port the GPIO is on
            var portIndex = Math.floor( gpioNumber / 32 );

            // Calculate the shift amount to get the mux mode value into the right
            // field in the register. Remember there are 16 GPIOs per register and
            // they each get two bits.
            var shiftAmount = (gpioNumber % 16) * 2;

            // Is the GPIO configured in MUX1 or MUX2?
            var regNumber = ( ( gpioNumber % 32 ) < 16 ) ? 0 : 1;

            // Calculate value for the GPn(G)MUX#_VALUE #defines.
            // Lower 2 bits are in GPnMUX#_VALUE, upper two are in GPnGMUX#_VALUE
            // Shift each GPIO's mux mode value into place and OR it in.
            muxValues[ portIndex ][ regNumber ][ 0 ] = ( muxValues[ portIndex ][ regNumber ][ 0 ] | ( ( assignment.muxMode & 0x3 ) << shiftAmount ) ) >>> 0;
            muxValues[ portIndex ][ regNumber ][ 1 ] = ( muxValues[ portIndex ][ regNumber ][ 1 ] | ( ( assignment.muxMode >> 2 ) << shiftAmount ) ) >>> 0;
            comments[ portIndex ].push( "// Pin " + assignment.devicePin.ball + " " +
                "(" + assignment.devicePin.designSignalName + ") " +
                "to " + assignment.peripheralPin.name + " " +
                "(mode " + assignment.muxMode + ")" );
            muxMasks[ portIndex ][ regNumber ] = ( muxMasks[ portIndex ][ regNumber ] | ( 0x3 << shiftAmount ) ) >>> 0;

            if ((gpioNumber == 42) || (gpioNumber == 43)) {
                // Make sure the AMSEL bit is cleared when 42 and 43 are not being used for USB
                var shiftAmount = gpioNumber % 32;

                amselComments[ portIndex ].push( "// Pin " + assignment.devicePin.ball + " " +
                    "(" + assignment.devicePin.designSignalName + ") " +
                    "to " + assignment.peripheralPin.name + " " +
                    "(mode " + assignment.muxMode + ")" );

                amselMasks[ portIndex ] = ( amselMasks[ portIndex ] | ( 0x1 << shiftAmount ) ) >>> 0;
            }

        }
    } );

    var toPaddedHex = function( value ) {
        var unPadded = ( value ).toString( 16 );
        var passing = "0x00000000";
        return passing.substr( 0, passing.length - unPadded.length ) + unPadded;
    };

    var poundDefineMask = function( portIndex, registerIndex ) {
        return "GP" + portIndices[ portIndex ] + "MUX" + ( registerIndex + 1 ) + "_MASK";
    };

    var poundDefineName = function( portIndex, registerIndex, isGroup ) {
        return "GP" + portIndices[ portIndex ] + ( ( isGroup === 1 ) ? "G" : "" ) +
            "MUX" + ( registerIndex + 1 ) + "_VALUE";
    };

    var amselPoundDefineName = function( portIndex ) {
        return "GP" + possibleIndices[ portIndex ] + "AMSEL_VALUE";
    };

    var amselPoundDefineMask = function( portIndex ) {
        return "GP" + possibleIndices[ portIndex ] + "AMSEL_MASK";
    };

    var xbarPoundDefineName = function( xbarNumber ) {
        return "INPUT" + (xbarNumber + 1) + "SELECT_VALUE";
    };

;
__p += '//*****************************************************************************\n//\n//  pinmux.h - Created using TI Pinmux ' +
((__t = (version)) == null ? '' : __t) +
' on ' +
((__t = (date.toLocaleDateString())) == null ? '' : __t) +
' at ' +
((__t = (date.toLocaleTimeString())) == null ? '' : __t) +
'.\n//\n//*****************************************************************************\n//\n// Copyright (C) 2017 Texas Instruments Incorporated - http://www.ti.com/\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions\n// are met:\n//\n//   Redistributions of source code must retain the above copyright\n//   notice, this list of conditions and the following disclaimer.\n//\n//   Redistributions in binary form must reproduce the above copyright\n//   notice, this list of conditions and the following disclaimer in the\n//   documentation and/or other materials provided with the\n//   distribution.\n//\n//   Neither the name of Texas Instruments Incorporated nor the names of\n//   its contributors may be used to endorse or promote products derived\n//   from this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//\n//*****************************************************************************\n//\n//  These values will provide the functionality requested when written into\n//  the registers for which the #defines are named.  For example, using the\n//  C2000Ware driverlib header files, use the defines like in this\n//  sample function:\n//\n//  void samplePinMuxFxn(void)\n//  {\n//      EALLOW;\n//      //\n//      // Write generated values to mux registers\n//      //\n//      HWREG(GPIOCTRL_BASE + GPIO_O_GPAMUX1)  = GPAMUX1_VALUE;\n//      HWREG(GPIOCTRL_BASE + GPIO_O_GPAMUX2)  = GPAMUX2_VALUE;\n//      HWREG(GPIOCTRL_BASE + GPIO_O_GPBMUX1)  = GPBMUX1_VALUE;\n//        . . .\n//      EDIS;\n//  }\n//\n//  NOTE:  These GPIO control registers are only available on CPU1.\n//\n//*****************************************************************************\n';
 for( var portIndex = 0; portIndex < portIndices.length; ++portIndex ) {
;
__p += '\n//\n// Port ' +
((__t = (portIndices[ portIndex ])) == null ? '' : __t) +
' mux register values\n//\n';
   _.each( comments[ portIndex ], function( comment ) {
;
__p +=
((__t = (comment)) == null ? '' : __t) +
'\n';
   } );
;
__p += '#define ' +
((__t = (poundDefineMask( portIndex, 0 ))) == null ? '' : __t) +
'		' +
((__t = (toPaddedHex( muxMasks[ portIndex ][ 0 ] ))) == null ? '' : __t) +
'\n';
   if( (needMUX2ForLastPort == true) || (portIndex != maxPortIndex) ) {
;
__p += '#define ' +
((__t = (poundDefineMask( portIndex, 1 ))) == null ? '' : __t) +
'		' +
((__t = (toPaddedHex( muxMasks[ portIndex ][ 1 ] ))) == null ? '' : __t) +
'\n';
   }
;
__p += '#define ' +
((__t = (poundDefineName( portIndex, 0, 0 ))) == null ? '' : __t) +
'		' +
((__t = (toPaddedHex( muxValues[ portIndex ][ 0 ][ 0 ] ))) == null ? '' : __t) +
'\n';
   if( (needMUX2ForLastPort == true) || (portIndex != maxPortIndex) ) {
;
__p += '#define ' +
((__t = (poundDefineName( portIndex, 1, 0 ))) == null ? '' : __t) +
'		' +
((__t = (toPaddedHex( muxValues[ portIndex ][ 1 ][ 0 ] ))) == null ? '' : __t) +
'\n';
   }
;
__p += '#define ' +
((__t = (poundDefineName( portIndex, 0, 1 ))) == null ? '' : __t) +
'		' +
((__t = (toPaddedHex( muxValues[ portIndex ][ 0 ][ 1 ] ))) == null ? '' : __t) +
'\n';
   if( (needMUX2ForLastPort == true) || (portIndex != maxPortIndex) ) {
;
__p += '#define ' +
((__t = (poundDefineName( portIndex, 1, 1 ))) == null ? '' : __t) +
'		' +
((__t = (toPaddedHex( muxValues[ portIndex ][ 1 ][ 1 ] ))) == null ? '' : __t) +
'\n';
   }
 }
;
__p += '\n';
 for( var portIndex = 0; portIndex < possibleIndices.length; ++portIndex ) {
   // Currently only supporting configuration of GPBAMSEL hence the "portIndex == 1" below
   if((portIndex == 1)) {
;
__p += '//\n// Port ' +
((__t = (possibleIndices[ portIndex ])) == null ? '' : __t) +
' analog mode register values\n//\n';
       _.each( amselComments[ portIndex ], function( comment ) {
;
__p +=
((__t = (comment)) == null ? '' : __t) +
'\n';
       } );
;
__p += '#define ' +
((__t = (amselPoundDefineMask( portIndex ))) == null ? '' : __t) +
'		' +
((__t = (toPaddedHex( amselMasks[ portIndex ] ))) == null ? '' : __t) +
'\n#define ' +
((__t = (amselPoundDefineName( portIndex ))) == null ? '' : __t) +
'		' +
((__t = (toPaddedHex( amselValues[ portIndex ] ))) == null ? '' : __t) +
'\n';
   }
 }
;
__p += '\n';
 if(xbarPresent == true) {
;
__p += '//\n// Input X-BAR register values\n//\n';
   for( var xbarIndex = 0; xbarIndex < xbarValues.length; ++xbarIndex ) {
       if((xbarComments[xbarIndex] != null)) {
;
__p +=
((__t = (xbarComments[ xbarIndex ])) == null ? '' : __t) +
'\n';
       }
   }
   for( var xbarIndex = 0; xbarIndex < xbarValues.length; ++xbarIndex ) {
       if((xbarValues[xbarIndex] != null)) {
;
__p += '#define ' +
((__t = (xbarPoundDefineName( xbarIndex ))) == null ? '' : __t) +
'	' +
((__t = (toPaddedHex( xbarValues[ xbarIndex ] ))) == null ? '' : __t) +
'\n';
       }
   }
;
__p += '\n';
 }
;
__p += '//*****************************************************************************\n//\n// Function prototype for function to write values above into their\n// corresponding registers. This function is found in pinmux.c. Its use is\n// completely optional.\n//\n//*****************************************************************************\nextern void GPIO_setPinMuxConfig(void);\n';
return __p
}; });