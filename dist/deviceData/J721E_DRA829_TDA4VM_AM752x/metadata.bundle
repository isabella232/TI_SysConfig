// This bundle was auto-generated on 2021-4-8 at 16:39:36
// From the folders: 
// /home/xgbsesvc/jenkins/jenkins/workspace/sysconfig.build.installers/pinmux/out/dist/deviceData/J721E_DRA829_TDA4VM_AM752x
defineResource("/J721E_DRA829_TDA4VM_AM752x/templates/Platform Development Kit (PDK)/J721E_pinmux.h.xdt", function(_, system, pmux, scripting, require) { "use strict";return function(args) {
var __t, __p = '', __j = Array.prototype.join;
function print() { __p += __j.call(arguments, '') }

 var $legacy = pmux.getScript("/legacy/adapt.js")(pmux), deviceData = $legacy.deviceData;
 var date = new Date();
;
__p += '/**\n * Note: This file was auto-generated by TI PinMux on ' +
((__t = (date.toLocaleDateString())) == null ? '' : __t) +
'.\n *\n * \\file   J721E_pinmux.h\n *\n * \\brief  This file contains pad configure register offsets and bit-field \n *         value macros for different configurations,\n *\n *           BIT[21]		TXDISABLE		disable the pin\'s output driver\n *           BIT[18]		RXACTIVE		enable the pin\'s input buffer (typically kept enabled)\n *           BIT[17]		PULLTYPESEL		set the iternal resistor pull direction high or low (if enabled)\n *           BIT[16]		PULLUDEN		internal resistor disable (0 = enabled / 1 = disabled)\n *           BIT[3:0]		MUXMODE			select the desired function on the given pin\n *\n *  \\copyright Copyright (CU) ' +
((__t = (date.getFullYear())) == null ? '' : __t) +
' Texas Instruments Incorporated - \n *             http://www.ti.com/\n */\n\n#ifndef _J721E_PIN_MUX_H_\n#define _J721E_PIN_MUX_H_\n\n/* ========================================================================== */\n/*                             Include Files                                  */\n/* ========================================================================== */\n\n#include "pinmux.h"\n#include "csl_types.h"\n\n#ifdef __cplusplus\nextern "C" {\n#endif\n\n/* ========================================================================== */\n/*                           Macros & Typedefs                                */\n/* ========================================================================== */\n#define PIN_MODE(mode)	                (mode)\n#define PINMUX_END                      (-1)\n\n/** \\brief Active mode configurations */\n/** \\brief Resistor enable */\n#define PIN_PULL_DISABLE                (0x1U << 16U)\n/** \\brief Pull direction */\n#define	PIN_PULL_DIRECTION              (0x1U << 17U)\n/** \\brief Receiver enable */\n#define	PIN_INPUT_ENABLE                (0x1U << 18U)\n/** \\brief Driver disable */\n#define	PIN_OUTPUT_DISABLE              (0x1U << 21U)\n/** \\brief Wakeup enable */\n#define	PIN_WAKEUP_ENABLE               (0x1U << 29U)\n\n/** \\brief Pad config register offset in control module */\nenum pinMainOffsets\n{\n    PIN_EXTINTN                = 0x0U,\n    PIN_PRG1_PRU0_GPO0         = 0x4U,\n    PIN_PRG1_PRU0_GPO1         = 0x8U,\n    PIN_PRG1_PRU0_GPO2         = 0xCU,\n    PIN_PRG1_PRU0_GPO3         = 0x10U,\n    PIN_PRG1_PRU0_GPO4         = 0x14U,\n    PIN_PRG1_PRU0_GPO5         = 0x18U,\n    PIN_PRG1_PRU0_GPO6         = 0x1CU,\n    PIN_PRG1_PRU0_GPO7         = 0x20U,\n    PIN_PRG1_PRU0_GPO8         = 0x24U,\n    PIN_PRG1_PRU0_GPO9         = 0x28U,\n    PIN_PRG1_PRU0_GPO10        = 0x2CU,\n    PIN_PRG1_PRU0_GPO11        = 0x30U,\n    PIN_PRG1_PRU0_GPO12        = 0x34U,\n    PIN_PRG1_PRU0_GPO13        = 0x38U,\n    PIN_PRG1_PRU0_GPO14        = 0x3CU,\n    PIN_PRG1_PRU0_GPO15        = 0x40U,\n    PIN_PRG1_PRU0_GPO16        = 0x44U,\n    PIN_PRG1_PRU0_GPO17        = 0x4CU,\n    PIN_PRG1_PRU0_GPO18        = 0x50U,\n    PIN_PRG1_PRU0_GPO19        = 0x54U,\n    PIN_PRG1_PRU1_GPO0         = 0x58U,\n    PIN_PRG1_PRU1_GPO1         = 0x5CU,\n    PIN_PRG1_PRU1_GPO2         = 0x60U,\n    PIN_PRG1_PRU1_GPO3         = 0x64U,\n    PIN_PRG1_PRU1_GPO4         = 0x68U,\n    PIN_PRG1_PRU1_GPO5         = 0x6CU,\n    PIN_PRG1_PRU1_GPO6         = 0x70U,\n    PIN_PRG1_PRU1_GPO7         = 0x74U,\n    PIN_PRG1_PRU1_GPO8         = 0x78U,\n    PIN_PRG1_PRU1_GPO9         = 0x7CU,\n    PIN_PRG1_PRU1_GPO10        = 0x80U,\n    PIN_PRG1_PRU1_GPO11        = 0x84U,\n    PIN_PRG1_PRU1_GPO12        = 0x88U,\n    PIN_PRG1_PRU1_GPO13        = 0x8CU,\n    PIN_PRG1_PRU1_GPO14        = 0x90U,\n    PIN_PRG1_PRU1_GPO15        = 0x94U,\n    PIN_PRG1_PRU1_GPO16        = 0x98U,\n    PIN_PRG1_PRU1_GPO17        = 0x9CU,\n    PIN_PRG1_PRU1_GPO18        = 0xA0U,\n    PIN_PRG1_PRU1_GPO19        = 0xA4U,\n    PIN_PRG1_MDIO0_MDIO        = 0xA8U,\n    PIN_PRG1_MDIO0_MDC         = 0xACU,\n    PIN_PRG0_PRU0_GPO0         = 0xB0U,\n    PIN_PRG0_PRU0_GPO1         = 0xB4U,\n    PIN_PRG0_PRU0_GPO2         = 0xB8U,\n    PIN_PRG0_PRU0_GPO3         = 0xBCU,\n    PIN_PRG0_PRU0_GPO4         = 0xC0U,\n    PIN_PRG0_PRU0_GPO5         = 0xC4U,\n    PIN_PRG0_PRU0_GPO6         = 0xC8U,\n    PIN_PRG0_PRU0_GPO7         = 0xCCU,\n    PIN_PRG0_PRU0_GPO8         = 0xD0U,\n    PIN_PRG0_PRU0_GPO9         = 0xD4U,\n    PIN_PRG0_PRU0_GPO10        = 0xD8U,\n    PIN_PRG0_PRU0_GPO11        = 0xDCU,\n    PIN_PRG0_PRU0_GPO12        = 0xE0U,\n    PIN_PRG0_PRU0_GPO13        = 0xE4U,\n    PIN_PRG0_PRU0_GPO14        = 0xE8U,\n    PIN_PRG0_PRU0_GPO15        = 0xECU,\n    PIN_PRG0_PRU0_GPO16        = 0xF0U,\n    PIN_PRG0_PRU0_GPO17        = 0xF4U,\n    PIN_PRG0_PRU0_GPO18        = 0xF8U,\n    PIN_PRG0_PRU0_GPO19        = 0xFCU,\n    PIN_PRG0_PRU1_GPO0         = 0x100U,\n    PIN_PRG0_PRU1_GPO1         = 0x104U,\n    PIN_PRG0_PRU1_GPO2         = 0x108U,\n    PIN_PRG0_PRU1_GPO3         = 0x10CU,\n    PIN_PRG0_PRU1_GPO4         = 0x110U,\n    PIN_PRG0_PRU1_GPO5         = 0x114U,\n    PIN_PRG0_PRU1_GPO6         = 0x118U,\n    PIN_PRG0_PRU1_GPO7         = 0x11CU,\n    PIN_PRG0_PRU1_GPO8         = 0x120U,\n    PIN_PRG0_PRU1_GPO9         = 0x124U,\n    PIN_PRG0_PRU1_GPO10        = 0x128U,\n    PIN_PRG0_PRU1_GPO11        = 0x12CU,\n    PIN_PRG0_PRU1_GPO12        = 0x130U,\n    PIN_PRG0_PRU1_GPO13        = 0x134U,\n    PIN_PRG0_PRU1_GPO14        = 0x138U,\n    PIN_PRG0_PRU1_GPO15        = 0x13CU,\n    PIN_PRG0_PRU1_GPO16        = 0x140U,\n    PIN_PRG0_PRU1_GPO17        = 0x144U,\n    PIN_PRG0_PRU1_GPO18        = 0x148U,\n    PIN_PRG0_PRU1_GPO19        = 0x14CU,\n    PIN_PRG0_MDIO0_MDIO        = 0x150U,\n    PIN_PRG0_MDIO0_MDC         = 0x154U,\n    PIN_RGMII5_TX_CTL          = 0x158U,\n    PIN_RGMII5_RX_CTL          = 0x15CU,\n    PIN_RGMII5_TD3             = 0x160U,\n    PIN_RGMII5_TD2             = 0x164U,\n    PIN_RGMII5_TD1             = 0x168U,\n    PIN_RGMII5_TD0             = 0x16CU,\n    PIN_RGMII5_TXC             = 0x170U,\n    PIN_RGMII5_RXC             = 0x174U,\n    PIN_RGMII5_RD3             = 0x178U,\n    PIN_RGMII5_RD2             = 0x17CU,\n    PIN_RGMII5_RD1             = 0x180U,\n    PIN_RGMII5_RD0             = 0x184U,\n    PIN_RGMII6_TX_CTL          = 0x188U,\n    PIN_RGMII6_RX_CTL          = 0x18CU,\n    PIN_RGMII6_TD3             = 0x190U,\n    PIN_RGMII6_TD2             = 0x194U,\n    PIN_RGMII6_TD1             = 0x198U,\n    PIN_RGMII6_TD0             = 0x19CU,\n    PIN_RGMII6_TXC             = 0x1A0U,\n    PIN_RGMII6_RXC             = 0x1A4U,\n    PIN_RGMII6_RD3             = 0x1A8U,\n    PIN_RGMII6_RD2             = 0x1ACU,\n    PIN_RGMII6_RD1             = 0x1B0U,\n    PIN_RGMII6_RD0             = 0x1B4U,\n    PIN_MDIO0_MDIO             = 0x1B8U,\n    PIN_MDIO0_MDC              = 0x1BCU,\n    PIN_SPI0_CS0               = 0x1C0U,\n    PIN_SPI0_CS1               = 0x1C4U,\n    PIN_SPI0_CLK               = 0x1C8U,\n    PIN_SPI0_D0                = 0x1CCU,\n    PIN_SPI0_D1                = 0x1D0U,\n    PIN_SPI1_CS0               = 0x1D4U,\n    PIN_SPI1_CS1               = 0x1D8U,\n    PIN_SPI1_CLK               = 0x1DCU,\n    PIN_SPI1_D0                = 0x1E0U,\n    PIN_SPI1_D1                = 0x1E4U,\n    PIN_UART0_RXD              = 0x1E8U,\n    PIN_UART0_TXD              = 0x1ECU,\n    PIN_UART0_CTSN             = 0x1F0U,\n    PIN_UART0_RTSN             = 0x1F4U,\n    PIN_UART1_RXD              = 0x1F8U,\n    PIN_UART1_TXD              = 0x1FCU,\n    PIN_UART1_CTSN             = 0x200U,\n    PIN_UART1_RTSN             = 0x204U,\n    PIN_MCAN0_RX               = 0x208U,\n    PIN_MCAN0_TX               = 0x20CU,\n    PIN_MCAN1_RX               = 0x210U,\n    PIN_MCAN1_TX               = 0x214U,\n    PIN_I3C0_SCL               = 0x218U,\n    PIN_I3C0_SDA               = 0x21CU,\n    PIN_I2C0_SCL               = 0x220U,\n    PIN_I2C0_SDA               = 0x224U,\n    PIN_I2C1_SCL               = 0x228U,\n    PIN_I2C1_SDA               = 0x22CU,\n    PIN_ECAP0_IN_APWM_OUT      = 0x230U,\n    PIN_EXT_REFCLK1            = 0x234U,\n    PIN_TIMER_IO0              = 0x238U,\n    PIN_TIMER_IO1              = 0x23CU,\n    PIN_MMC1_DAT3              = 0x240U,\n    PIN_MMC1_DAT2              = 0x244U,\n    PIN_MMC1_DAT1              = 0x248U,\n    PIN_MMC1_DAT0              = 0x24CU,\n    PIN_MMC1_CLK               = 0x250U,\n    PIN_MMC1_CMD               = 0x254U,\n    PIN_MMC1_SDCD              = 0x258U,\n    PIN_MMC1_SDWP              = 0x25CU,\n    PIN_MMC2_DAT3              = 0x260U,\n    PIN_MMC2_DAT2              = 0x264U,\n    PIN_MMC2_DAT1              = 0x268U,\n    PIN_MMC2_DAT0              = 0x26CU,\n    PIN_MMC2_CLK               = 0x270U,\n    PIN_MMC2_CMD               = 0x274U,\n    PIN_RESETSTATZ             = 0x278U,\n    PIN_PORZ_OUT               = 0x27CU,\n    PIN_SOC_SAFETY_ERRORN      = 0x280U,\n    PIN_TDI                    = 0x284U,\n    PIN_TDO                    = 0x288U,\n    PIN_TMS                    = 0x28CU,\n    PIN_USB0_DRVVBUS           = 0x290U,\n    PIN_MLB0_MLBSP             = 0x294U,\n    PIN_MLB0_MLBSN             = 0x298U,\n    PIN_MLB0_MLBDP             = 0x29CU,\n    PIN_MLB0_MLBDN             = 0x2A0U,\n    PIN_MLB0_MLBCP             = 0x2A4U,\n    PIN_MLB0_MLBCN             = 0x2A8U,\n    PIN_MMC1_CLKLB             = 0x2ACU,\n    PIN_MMC2_CLKLB             = 0x2B0U,\n};\n\nenum pinWkupOffsets\n{\n    PIN_MCU_OSPI0_CLK          = 0x0U,\n    PIN_MCU_OSPI0_LBCLKO       = 0x4U,\n    PIN_MCU_OSPI0_DQS          = 0x8U,\n    PIN_MCU_OSPI0_D0           = 0xCU,\n    PIN_MCU_OSPI0_D1           = 0x10U,\n    PIN_MCU_OSPI0_D2           = 0x14U,\n    PIN_MCU_OSPI0_D3           = 0x18U,\n    PIN_MCU_OSPI0_D4           = 0x1CU,\n    PIN_MCU_OSPI0_D5           = 0x20U,\n    PIN_MCU_OSPI0_D6           = 0x24U,\n    PIN_MCU_OSPI0_D7           = 0x28U,\n    PIN_MCU_OSPI0_CSN0         = 0x2CU,\n    PIN_MCU_OSPI0_CSN1         = 0x30U,\n    PIN_MCU_OSPI1_CLK          = 0x34U,\n    PIN_MCU_OSPI1_LBCLKO       = 0x38U,\n    PIN_MCU_OSPI1_DQS          = 0x3CU,\n    PIN_MCU_OSPI1_D0           = 0x40U,\n    PIN_MCU_OSPI1_D1           = 0x44U,\n    PIN_MCU_OSPI1_D2           = 0x48U,\n    PIN_MCU_OSPI1_D3           = 0x4CU,\n    PIN_MCU_OSPI1_CSN0         = 0x50U,\n    PIN_MCU_OSPI1_CSN1         = 0x54U,\n    PIN_MCU_RGMII1_TX_CTL      = 0x58U,\n    PIN_MCU_RGMII1_RX_CTL      = 0x5CU,\n    PIN_MCU_RGMII1_TD3         = 0x60U,\n    PIN_MCU_RGMII1_TD2         = 0x64U,\n    PIN_MCU_RGMII1_TD1         = 0x68U,\n    PIN_MCU_RGMII1_TD0         = 0x6CU,\n    PIN_MCU_RGMII1_TXC         = 0x70U,\n    PIN_MCU_RGMII1_RXC         = 0x74U,\n    PIN_MCU_RGMII1_RD3         = 0x78U,\n    PIN_MCU_RGMII1_RD2         = 0x7CU,\n    PIN_MCU_RGMII1_RD1         = 0x80U,\n    PIN_MCU_RGMII1_RD0         = 0x84U,\n    PIN_MCU_MDIO0_MDIO         = 0x88U,\n    PIN_MCU_MDIO0_MDC          = 0x8CU,\n    PIN_MCU_SPI0_CLK           = 0x90U,\n    PIN_MCU_SPI0_D0            = 0x94U,\n    PIN_MCU_SPI0_D1            = 0x98U,\n    PIN_MCU_SPI0_CS0           = 0x9CU,\n    PIN_WKUP_UART0_RXD         = 0xA0U,\n    PIN_WKUP_UART0_TXD         = 0xA4U,\n    PIN_MCU_MCAN0_TX           = 0xA8U,\n    PIN_MCU_MCAN0_RX           = 0xACU,\n    PIN_WKUP_GPIO0_0           = 0xB0U,\n    PIN_WKUP_GPIO0_1           = 0xB4U,\n    PIN_WKUP_GPIO0_2           = 0xB8U,\n    PIN_WKUP_GPIO0_3           = 0xBCU,\n    PIN_WKUP_GPIO0_4           = 0xC0U,\n    PIN_WKUP_GPIO0_5           = 0xC4U,\n    PIN_WKUP_GPIO0_6           = 0xC8U,\n    PIN_WKUP_GPIO0_7           = 0xCCU,\n    PIN_WKUP_GPIO0_8           = 0xD0U,\n    PIN_WKUP_GPIO0_9           = 0xD4U,\n    PIN_WKUP_GPIO0_10          = 0xD8U,\n    PIN_WKUP_GPIO0_11          = 0xDCU,\n    PIN_WKUP_GPIO0_12          = 0xE0U,\n    PIN_WKUP_GPIO0_13          = 0xE4U,\n    PIN_WKUP_GPIO0_14          = 0xE8U,\n    PIN_WKUP_GPIO0_15          = 0xECU,\n    PIN_MCU_I3C0_SCL           = 0xF0U,\n    PIN_MCU_I3C0_SDA           = 0xF4U,\n    PIN_WKUP_I2C0_SCL          = 0xF8U,\n    PIN_WKUP_I2C0_SDA          = 0xFCU,\n    PIN_MCU_I2C0_SCL           = 0x100U,\n    PIN_MCU_I2C0_SDA           = 0x104U,\n    PIN_PMIC_POWER_EN0         = 0x108U,\n    PIN_PMIC_POWER_EN1         = 0x10CU,\n    PIN_MCU_SAFETY_ERRORN      = 0x110U,\n    PIN_MCU_RESETZ             = 0x114U,\n    PIN_MCU_RESETSTATZ         = 0x118U,\n    PIN_MCU_PORZ_OUT           = 0x11CU,\n    PIN_TCK                    = 0x120U,\n    PIN_TRSTN                  = 0x124U,\n    PIN_EMU0                   = 0x128U,\n    PIN_EMU1                   = 0x12CU,\n    PIN_MCU_ADC0_AIN0          = 0x130U,\n    PIN_MCU_ADC0_AIN1          = 0x134U,\n    PIN_MCU_ADC0_AIN2          = 0x138U,\n    PIN_MCU_ADC0_AIN3          = 0x13CU,\n    PIN_MCU_ADC0_AIN4          = 0x140U,\n    PIN_MCU_ADC0_AIN5          = 0x144U,\n    PIN_MCU_ADC0_AIN6          = 0x148U,\n    PIN_MCU_ADC0_AIN7          = 0x14CU,\n    PIN_MCU_ADC1_AIN0          = 0x150U,\n    PIN_MCU_ADC1_AIN1          = 0x154U,\n    PIN_MCU_ADC1_AIN2          = 0x158U,\n    PIN_MCU_ADC1_AIN3          = 0x15CU,\n    PIN_MCU_ADC1_AIN4          = 0x160U,\n    PIN_MCU_ADC1_AIN5          = 0x164U,\n    PIN_MCU_ADC1_AIN6          = 0x168U,\n    PIN_MCU_ADC1_AIN7          = 0x16CU,\n    PIN_RESET_REQZ             = 0x170U,\n    PIN_PORZ                   = 0x174U,\n};\n\n/* ========================================================================== */\n/*                            Global Variables                                */\n/* ========================================================================== */\n\n/** \\brief Pinmux configuration data for the board. Auto-generated from \n           Pinmux tool. */\nextern pinmuxBoardCfg_t gJ721E_MainPinmuxData[];\nextern pinmuxBoardCfg_t gJ721E_WkupPinmuxData[];\n\n#ifdef __cplusplus\n}\n#endif /* __cplusplus */\n#endif /* _J721E_PIN_MUX_H_ */\n';
return __p
}; });
defineResource("/J721E_DRA829_TDA4VM_AM752x/templates/Platform Development Kit (PDK)/J721E_pinmux_data.c.xdt", function(_, system, pmux, scripting, require) { "use strict";return function(args) {
var __t, __p = '', __j = Array.prototype.join;
function print() { __p += __j.call(arguments, '') }

 var $legacy = pmux.getScript("/legacy/adapt.js")(pmux), assignments = $legacy.assignments;
 var date = new Date();
;
__p += '/**\n* Note: This file was auto-generated by TI PinMux on ' +
((__t = (date.toLocaleDateString())) == null ? '' : __t) +
' at ' +
((__t = (date.toLocaleTimeString())) == null ? '' : __t) +
'.\n*\n* \\file  J721E_pinmux_data.c\n*\n* \\brief  This file contains the pin mux configurations for the boards.\n*         These are prepared based on how the peripherals are extended on\n*         the boards.\n*\n* \\copyright Copyright (CU) ' +
((__t = (date.getFullYear())) == null ? '' : __t) +
' Texas Instruments Incorporated -\n*             http://www.ti.com/\n*/\n\n/* ========================================================================== */\n/*                             Include Files                                  */\n/* ========================================================================== */\n\n#include "J721E_pinmux.h"\n\n/** Peripheral Pin Configurations */\n\n';

    var capitalizeFirstLetterOnly = function( name ) {
        return name[0].toUpperCase() + name.substring( 1, name.length ).toLowerCase();
    };

    var getMappedInterface = function( assignment ) {
        // hack for maxwell
        // return assignment.interfaceName.substring(0, assignment.interfaceName.length-1);
        // hack for maxwell no longer needed
        return assignment.interfaceName;
    };

    var getPeripheralNum = function( assignment ) {
        // Look at the last character in the peripheral name.
        // If it's a number then we use that. Otherwise, use 0.

        var lastChar = parseInt( assignment.peripheral.name[ assignment.peripheral.name.length - 1 ] );
            if( isNaN( lastChar ) ) {
                return 0;
            }
        return lastChar;
    };

    var getMappedPeripheral = function( assignment ) {
        return getMappedInterface( assignment ) + getPeripheralNum( assignment );
    };

    var getPeripheralInstNum = function( assignment ) {
        var optionalParameters = getMappedPeripheral(assignment);
        // Look at the last character in the peripheral name.
        // If it's a number, then we use that.  Otherwise, use 0.
        if(optionalParameters == assignment.interfaceName)
        {
            var lastChar = parseInt( assignment.peripheral.name[ assignment.peripheral.name.length - 1 ] );
        }
        else
        {
            var lastChar = parseInt( optionalParameters[ optionalParameters.length - 1 ] );
        }
        if( isNaN( lastChar ) ) {
            return 0;
        }
        return lastChar;
    };

    var OPT_PARAM = function( assignment ) {
        // optional parameters for pinmuxing
        // For everything, return 0. Not used in Maxwell.

        return 0;
    }

    var PinOptions = function( assignment ) {
        var options = [];
        var notOptions = [];

        var addOption = function( option ) {
            if( option[0] === '~' ) {
                notOptions.push( option );
            } else {
                options.push( option );
            }
        };

        var IS_PULL_ENABLED = function() {
            if( assignment.pu || assignment.pd ) {
                return "~PIN_PULL_DISABLE";
            }
            return "PIN_PULL_DISABLE";
        };

        var PULL_TYPE = function() {
            if( assignment.pu ) {
                return "PIN_PULL_DIRECTION";
            }
            return "~PIN_PULL_DIRECTION";
        };

        var IS_RX_ACTIVE = function() {
            if( assignment.rx || assignment.RX) {
                return "PIN_INPUT_ENABLE";
            }
            return "~PIN_INPUT_ENABLE";
        };

        addOption( IS_PULL_ENABLED() );
        addOption( PULL_TYPE() );
        addOption( IS_RX_ACTIVE() );

        var formatOptions = function( optionsList, operator ) {
            if(optionsList.length == 0) {
                if (operator === " | ") {
                    var result = "(0x50000";
                }
                if (operator === " & ") {
                    var result = "(0x50000";
                }
            }
            else {
                var result = "(";
            }
            for( var i = 0; i < optionsList.length; ++i ) {
                result += optionsList[i];
                if( i != optionsList.length - 1 ) {
                    result += operator;
                }
            }
            result += ")";
            return result;
        };

        this.getOptions = function() {
            return formatOptions( options, " | " );
        }

        this.getNotOptions = function() {
            return formatOptions( notOptions, " & " );
        }
    }

    // First, we need to sort all pin assigments into their mapped interfaces/
    // peripherals.  This mapping isn't what pinmux knows, so we have to do it

    var mappedAssignments = {};
    for( var i = 0; i < assignments.length; ++i ) {
        if( "NOT FOUND" == assignments[i].devicePin.controlRegisterOffset ) {
            // do nothing with pins that have no pad configuration register
        } else {
            var interfaceName = getMappedInterface( assignments[i] );
            var peripheralName = getMappedPeripheral( assignments[i] );
            mappedAssignments[ interfaceName ] = mappedAssignments[ interfaceName ] || {};
            mappedAssignments[ interfaceName ][ peripheralName ] = mappedAssignments[ interfaceName ][ peripheralName ] || [];
            mappedAssignments[ interfaceName ][ peripheralName ].push( assignments[i] );
        }
    }

;
__p += '\n';


   _.each( mappedAssignments, function( peripherals, interfaceName ) {

       _.each( peripherals, function( pins, peripheralName ) {
;
__p += 'static pinmuxPerCfg_t g' +
((__t = (capitalizeFirstLetterOnly( peripheralName ))) == null ? '' : __t) +
'PinCfg[] =\n{\n';

var enumStatements = [];
for( var i = 0; i < pins.length; ++i ) {
    if ( undefined !== pins[i].devicePin.controlRegisterOffset && "NOT FOUND" !== pins[i].devicePin.controlRegisterOffset ) {
        var pinOptions = new PinOptions( pins[i] );
        enumStatements.push(
        {
            line1 : "/* " + pins[i].requirementName + " -> " + pins[i].peripheralPin.name + " -> " + pins[i].devicePin.ball + " */",
            line2 : "{",
            line3 : "    PIN_" + pins[i].devicePin.designSignalName.toUpperCase() + ", " + "PIN_MODE(" + pins[i].muxMode + ") | \\",
            line4 : "    (" + pinOptions.getOptions() + " & " + pinOptions.getNotOptions() + ")",
            line5 : "},"
        });
		if ( _.includes(pins[i].peripheralPin.name, "MMC1_CLK") ) {
			enumStatements.push(
			{
				line1 : "/* " + pins[i].requirementName + " -> " + "MMC1_CLKLB -> P25 */",
				line2 : "{",
				line3 : "    PIN_MMC1_CLKLB, PIN_MODE(0) | \\",
				line4 : "    ((PIN_PULL_DISABLE | PIN_INPUT_ENABLE) & (~PIN_PULL_DIRECTION))",
				line5 : "},"
			});
		}
		if ( _.includes(pins[i].peripheralPin.name, "MMC2_CLK") ) {
			enumStatements.push(
			{
				line1 : "/* " + pins[i].requirementName + " -> " + "MMC2_CLKLB -> T26 */",
				line2 : "{",
				line3 : "    PIN_MMC2_CLKLB, PIN_MODE(0) | \\",
				line4 : "    ((PIN_PULL_DISABLE | PIN_INPUT_ENABLE) & (~PIN_PULL_DIRECTION))",
				line5 : "},"
			});
		}
    }
}
 for( var i = 0; i < enumStatements.length; ++i ) {
;
__p += '    ' +
((__t = (enumStatements[i].line1)) == null ? '' : __t) +
'\n    ' +
((__t = (enumStatements[i].line2)) == null ? '' : __t) +
'\n    ' +
((__t = (enumStatements[i].line3)) == null ? '' : __t) +
'\n    ' +
((__t = (enumStatements[i].line4)) == null ? '' : __t) +
'\n    ' +
((__t = (enumStatements[i].line5)) == null ? '' : __t) +
'\n';
 }
;
__p += '    {PINMUX_END}\n};\n\n';
 });
;
__p += 'static pinmuxModuleCfg_t g' +
((__t = (capitalizeFirstLetterOnly( interfaceName ))) == null ? '' : __t) +
'PinCfg[] =\n{\n';
 _.each( peripherals, function( pins, peripheralName ) {
;
__p += '    {' +
((__t = (getPeripheralInstNum( pins[0] ))) == null ? '' : __t) +
', TRUE, g' +
((__t = (capitalizeFirstLetterOnly( peripheralName ))) == null ? '' : __t) +
'PinCfg},\n';
 });
;
__p += '    {PINMUX_END}\n};\n\n\n';
 });

var enumMainSet = [];
var enumWkupSet = [];
_.each( mappedAssignments, function( pins, interfaceName ) {
    if ( interfaceName.startsWith("WKUP") || interfaceName.startsWith("MCU") ) {
        enumWkupSet.push("g" + capitalizeFirstLetterOnly( interfaceName ) + "PinCfg");
    } else {
        enumMainSet.push("g" + capitalizeFirstLetterOnly( interfaceName ) + "PinCfg");
    }
});
;
__p += 'pinmuxBoardCfg_t gJ721E_MainPinmuxData[] =\n{\n';
   for( var i = 0; i < enumMainSet.length; ++i ) {
;
__p += '    {' +
((__t = (i)) == null ? '' : __t) +
', ' +
((__t = (enumMainSet[i])) == null ? '' : __t) +
'},\n';
   }
;
__p += '    {PINMUX_END}\n};\n\npinmuxBoardCfg_t gJ721E_WkupPinmuxData[] =\n{\n';
   for( var i = 0; i < enumWkupSet.length; ++i ) {
;
__p += '    {' +
((__t = (i)) == null ? '' : __t) +
', ' +
((__t = (enumWkupSet[i])) == null ? '' : __t) +
'},\n';
   }
;
__p += '    {PINMUX_END}\n};\n';
return __p
}; });
defineResource("/J721E_DRA829_TDA4VM_AM752x/templates/csv/PinmuxConfigSummary.csv.xdt", function(_, system, pmux, scripting, require) { "use strict";return function(args) {
var __t, __p = '', __j = Array.prototype.join;
function print() { __p += __j.call(arguments, '') }

 var $legacy = pmux.getScript("/legacy/adapt.js")(pmux), assignmentErrors = $legacy.assignmentErrors, assignments = $legacy.assignments;

var parseMux = function ( thisMux ) {
    if (thisMux > 14) {
        return thisMux;
    } else if (thisMux > 10) {
        return 1;
    } else if (thisMux > 7) {
        return 0;
    }
    return thisMux;
	
};

var getRxEnable = function ( assignment ) {
	
    if (assignment.rx !== null) {
        return assignment.rx;
    } else if (assignment.RX !== null) {
        return assignment.RX;
    } 
	
	
    return assignment.rx;
};

;
__p += 'Design Signal Pad Name,IO Power Group,PUPD State During HHV,PUPD State After HHV,IO Power Supply Name,IO Power Setting,Required Voltage Level,Ball Name,Selected Mode Number,Mode Interface Name,Mode Signal Name,Mode Type,User Checked PU,User Checked PD,User Checked RX,User Requirement Name\n';
 for( var i = 0; i < assignments.length; ++i ) {
;
__p +=
((__t = (assignments[i].devicePin.designSignalName)) == null ? '' : __t) +
',' +
((__t = (assignments[i].devicePin.powerDomain.powerGroup)) == null ? '' : __t) +
',' +
((__t = (assignments[i].devicePin.pupdStateDuringHHV)) == null ? '' : __t) +
',' +
((__t = (assignments[i].devicePin.pupdStateAfterHHV)) == null ? '' : __t) +
',' +
((__t = (assignments[i].devicePin.powerDomain.name)) == null ? '' : __t) +
',' +
((__t = (assignments[i].powerSetting)) == null ? '' : __t) +
',' +
((__t = (assignments[i].requiredVoltageLevel)) == null ? '' : __t) +
',' +
((__t = (assignments[i].devicePin.ball)) == null ? '' : __t) +
',' +
((__t = (assignments[i].muxMode)) == null ? '' : __t) +
',' +
((__t = (assignments[i].peripheral.name)) == null ? '' : __t) +
',' +
((__t = (assignments[i].peripheralPin.name)) == null ? '' : __t) +
',' +
((__t = (assignments[i].peripheralPin.interfacePin.receiver)) == null ? '' : __t) +
',' +
((__t = (assignments[i].pu)) == null ? '' : __t) +
',' +
((__t = (assignments[i].pd)) == null ? '' : __t) +
',' +
((__t = (getRxEnable(assignments[i]))) == null ? '' : __t) +
',' +
((__t = (assignments[i].requirementName)) == null ? '' : __t) +
'\n';
 }
;

return __p
}; });
defineResource("/J721E_DRA829_TDA4VM_AM752x/templates/linux/devicetree.dtsi.xdt", function(_, system, pmux, scripting, require) { "use strict";return function(args) {
var __t, __p = '', __j = Array.prototype.join;
function print() { __p += __j.call(arguments, '') }

 var $legacy = pmux.getScript("/legacy/adapt.js")(pmux), assignments = $legacy.assignments;

var groupedAssignmentsMAIN = {};
var groupedAssignmentsWKUP = {};
var notUsedAssignments = {};

_( assignments ).each( function( assignment ) {
	// Use the requirement name as the name, but lower case and _ instead of spaces

	var requirementName = assignment.requirementName.toLowerCase().replace( / /g, "_" );
	if( "NOT FOUND" !== assignment.devicePin.controlRegisterOffset ) {
		if ( _.includes(assignment.interfaceName, "WKUP") || _.includes(assignment.interfaceName, "MCU") ) {
			groupedAssignmentsWKUP[ assignment.interfaceName ] = groupedAssignmentsWKUP[ assignment.interfaceName ] || {};
			groupedAssignmentsWKUP[ assignment.interfaceName ][ requirementName ] = groupedAssignmentsWKUP[ assignment.interfaceName ][ requirementName ] || [];
			groupedAssignmentsWKUP[ assignment.interfaceName ][ requirementName ].push( assignment );
		} else {
			groupedAssignmentsMAIN[ assignment.interfaceName ] = groupedAssignmentsMAIN[ assignment.interfaceName ] || {};
			groupedAssignmentsMAIN[ assignment.interfaceName ][ requirementName ] = groupedAssignmentsMAIN[ assignment.interfaceName ][ requirementName ] || [];
			groupedAssignmentsMAIN[ assignment.interfaceName ][ requirementName ].push( assignment );
		}
	} else {
		notUsedAssignments[ assignment.interfaceName ] = notUsedAssignments[ assignment.interfaceName ] || {};
		notUsedAssignments[ assignment.interfaceName ][ requirementName ] = {};
	}
} );

var getOffset = function( assignment ) {
	return ( assignment.devicePin.controlRegisterOffset ).toString( 16 ).toLowerCase();
};

var getPinConfig = function( assignment ) {
	var result = "";
	
	if( assignment.rx || assignment.RX) {
		if( assignment.pu ) {
			result += "PIN_INPUT_PULLUP";
		}
		else if( assignment.pd ) {
			result += "PIN_INPUT_PULLDOWN";
		}
		else {
			result += "PIN_INPUT";
		}
	} else {
		if( assignment.pu ) {
			result += "PIN_OUTPUT_PULLUP";
		}
		else if( assignment.pd ) {
			result += "PIN_OUTPUT_PULLDOWN";
		}
		else {
			result += "PIN_OUTPUT";
		}
	}
	return result;
};

var getPinMuxMode = function( assignment ) {
	return ( assignment.muxMode ).toString ( 10 );
};

var getPinComment = function( assignment ) {
	if (assignment.devicePin.designSignalName == assignment.peripheralPin.name) {
		return "/* (" + assignment.devicePin.ball + ") " + assignment.devicePin.designSignalName + " */";
	} else {
		return "/* (" + assignment.devicePin.ball + ") " + assignment.devicePin.designSignalName + "." + assignment.peripheralPin.name + " */";
	}
};

var date = new Date();

;
__p += '/* This file was auto-generated by TI PinMux on ' +
((__t = (date.toLocaleDateString())) == null ? '' : __t) +
' at ' +
((__t = (date.toLocaleTimeString())) == null ? '' : __t) +
'. */\n/* This file should only be used as a reference. Some pins/peripherals, */\n/* depending on your use case, may need additional configuration. */\n\n';
 if( !_( notUsedAssignments ).isEmpty() ) {
;
__p += '/* Some or all of the pins from the following groups are not used by the device tree\n';
	_( notUsedAssignments ).each( function( iFace ) {
		_( iFace ).each( function( requirement, requirementName ) {
;
__p += '	' +
((__t = (requirementName)) == null ? '' : __t) +
'\n';
		} );
	} );
;
__p += '*/\n\n';
 }
 if( !_( groupedAssignmentsMAIN ).isEmpty() ) {
;
__p += '&main_pmx0 {\n';
	_( groupedAssignmentsMAIN ).each( function( iFace ) {
		_( iFace ).each( function( requirement, requirementName ) {
;
__p += '	' +
((__t = (requirementName)) == null ? '' : __t) +
'_pins_default: ' +
((__t = (requirementName)) == null ? '' : __t) +
'_pins_default {\n		pinctrl-single,pins = <\n';
			_( requirement ).each( function( assignment ) {
;
__p += '			J721E_IOPAD(' +
((__t = (getOffset( assignment ))) == null ? '' : __t) +
', ' +
((__t = (getPinConfig( assignment ))) == null ? '' : __t) +
', ' +
((__t = (getPinMuxMode( assignment ))) == null ? '' : __t) +
') ' +
((__t = (getPinComment( assignment ))) == null ? '' : __t) +
'\n';
			if ( _.includes(assignment.peripheralPin.name, "MMC1_CLK") ) {
;
__p += '			J721E_IOPAD(0x2ac, PIN_INPUT, 0) /* (P25) MMC1_CLKLB */\n';
			}
			if ( _.includes(assignment.peripheralPin.name, "MMC2_CLK") ) {
;
__p += '			J721E_IOPAD(0x2b0, PIN_INPUT, 0) /* (T26) MMC2_CLKLB */\n';
			}
			} );
;
__p += '		>;\n	};\n\n';
		} );
	} );
;
__p += '};\n\n';
 }
 if( !_( groupedAssignmentsWKUP ).isEmpty() ) {
;
__p += '&wkup_pmx0 {\n';
	_( groupedAssignmentsWKUP ).each( function( iFace ) {
		_( iFace ).each( function( requirement, requirementName ) {
;
__p += '	' +
((__t = (requirementName)) == null ? '' : __t) +
'_pins_default: ' +
((__t = (requirementName)) == null ? '' : __t) +
'_pins_default {\n		pinctrl-single,pins = <\n';
			_( requirement ).each( function( assignment ) {
;
__p += '			J721E_WKUP_IOPAD(' +
((__t = (getOffset( assignment ))) == null ? '' : __t) +
', ' +
((__t = (getPinConfig( assignment ))) == null ? '' : __t) +
', ' +
((__t = (getPinMuxMode( assignment ))) == null ? '' : __t) +
') ' +
((__t = (getPinComment( assignment ))) == null ? '' : __t) +
'\n';
			} );
;
__p += '		>;\n	};\n\n';
		} );
	} );
;
__p += '};\n';
 }
;

return __p
}; });