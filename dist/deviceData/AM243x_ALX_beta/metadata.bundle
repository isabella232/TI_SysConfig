defineResource("/AM243x_ALX_beta/templates/Platform Development Kit (PDK)/AM243x_ALX_pinmux.h.xdt", function(_, system, pmux, scripting, require) { "use strict";return function(args) {
var __t, __p = '', __j = Array.prototype.join;
function print() { __p += __j.call(arguments, '') }

 var $legacy = pmux.getScript("/legacy/adapt.js")(pmux), assignments = $legacy.assignments;
 var date = new Date();
;
__p += '/**\n * Note: This file was auto-generated by TI PinMux on ' +
((__t = (date.toLocaleDateString())) == null ? '' : __t) +
'.\n *\n * \\file   AM243x_ALX_pinmux.h\n *\n * \\brief  This file contains pad configure register offsets and bit-field \n *         value macros for different configurations,\n *\n *           BIT[21]		TXDISABLE		disable the pin\'s output driver\n *           BIT[18]		RXACTIVE		enable the pin\'s input buffer (typically kept enabled)\n *           BIT[17]		PULLTYPESEL		set the iternal resistor pull direction high or low (if enabled)\n *           BIT[16]		PULLUDEN		internal resistor disable (0 = enabled / 1 = disabled)\n *           BIT[3:0]		MUXMODE			select the desired function on the given pin\n *\n *  \\copyright Copyright (CU) ' +
((__t = (date.getFullYear())) == null ? '' : __t) +
' Texas Instruments Incorporated - \n *             http://www.ti.com/\n */\n\n#ifndef _AM243x_ALX_PIN_MUX_H_\n#define _AM243x_ALX_PIN_MUX_H_\n\n/* ========================================================================== */\n/*                             Include Files                                  */\n/* ========================================================================== */\n\n#include "pinmux.h"\n#include "csl_types.h"\n\n#ifdef __cplusplus\nextern "C" {\n#endif\n\n/* ========================================================================== */\n/*                           Macros & Typedefs                                */\n/* ========================================================================== */\n#define PIN_MODE(mode)	                (mode)\n#define PINMUX_END                      (-1)\n\n/** \\brief Active mode configurations */\n/** \\brief Resistor enable */\n#define PIN_PULL_DISABLE                (0x1U << 16U)\n/** \\brief Pull direction */\n#define	PIN_PULL_DIRECTION              (0x1U << 17U)\n/** \\brief Receiver enable */\n#define	PIN_INPUT_ENABLE                (0x1U << 18U)\n/** \\brief Driver disable */\n#define	PIN_OUTPUT_DISABLE              (0x1U << 21U)\n/** \\brief Wakeup enable */\n#define	PIN_WAKEUP_ENABLE               (0x1U << 29U)\n\n/** \\brief Pad config register offset in control module */\n';

	var enumMainSet = [];
	var enumWkupSet = [];
	
	// exception for pins with no MCU/WKUP domain prefix in the names, they should still go in the Wkup array
	var wkupPinsExc = {
						"TDI" : "", 
						"TDO" : "", 
						"PMIC_POWER_EN1" : "", 
						"TCK" : "",
						"TRSTN" : "",
						"EMU0" : "",
						"EMU1" : "",
						"RESET_REQZ" : "",
						"PORZ" : "",
						"ATEST0" : "",
						"TEMP_DIODE_P" : "",
					}
	
	for( var i = 0; i < assignments.length; ++i ) {
	
		var assignment = assignments[i];
		var interfaceName = assignment.interfaceName;
		var pinName = assignment.devicePin.designSignalName.toUpperCase();
		var s_devicePinNameAndOffset = "PIN_" + pinName + "\t\t = " + assignment.devicePin.controlRegisterOffset+",";
		
		if( assignment.devicePin.controlRegisterOffset !== "NOT FOUND" ) {
			if ( interfaceName.startsWith("WKUP") || interfaceName.startsWith("MCU") || (pinName in wkupPinsExc)) {
				enumWkupSet.push(s_devicePinNameAndOffset);
			} else {
				enumMainSet.push(s_devicePinNameAndOffset);
			}
		}
    }
;
__p += '\nenum pinMainOffsets\n{\n';
for (var i = 0; i < enumMainSet.length; i++){
;
__p += '	' +
((__t = (enumMainSet[i])) == null ? '' : __t) +
'\n';
}   
;
__p += '};\n\nenum pinWkupOffsets\n{\n';
for (var i = 0; i < enumWkupSet.length; i++){
;
__p += '	' +
((__t = (enumWkupSet[i])) == null ? '' : __t) +
'\n';
}
;
__p += '};\n\n/* ========================================================================== */\n/*                            Global Variables                                */\n/* ========================================================================== */\n\n/** \\brief Pinmux configuration data for the board. Auto-generated from \n           Pinmux tool. */\nextern pinmuxBoardCfg_t gAM243x_ALX_MainPinmuxData[];\nextern pinmuxBoardCfg_t gAM243x_ALX_WkupPinmuxData[];\n\n#ifdef __cplusplus\n}\n#endif /* __cplusplus */\n#endif /* _AM243x_ALX_PIN_MUX_H_ */\n';
return __p
}; });
defineResource("/AM243x_ALX_beta/templates/Platform Development Kit (PDK)/AM243x_ALX_pinmux_data.c.xdt", function(_, system, pmux, scripting, require) { "use strict";return function(args) {
var __t, __p = '', __j = Array.prototype.join;
function print() { __p += __j.call(arguments, '') }

 var $legacy = pmux.getScript("/legacy/adapt.js")(pmux), assignments = $legacy.assignments;
 var date = new Date();
;
__p += '/**\n* Note: This file was auto-generated by TI PinMux on ' +
((__t = (date.toLocaleDateString())) == null ? '' : __t) +
' at ' +
((__t = (date.toLocaleTimeString())) == null ? '' : __t) +
'.\n*\n* \\file  AM243x_ALX_pinmux_data.c\n*\n* \\brief  This file contains the pin mux configurations for the boards.\n*         These are prepared based on how the peripherals are extended on\n*         the boards.\n*\n* \\copyright Copyright (CU) ' +
((__t = (date.getFullYear())) == null ? '' : __t) +
' Texas Instruments Incorporated -\n*             http://www.ti.com/\n*/\n\n/* ========================================================================== */\n/*                             Include Files                                  */\n/* ========================================================================== */\n\n#include "AM243x_ALX_pinmux.h"\n\n/** Peripheral Pin Configurations */\n\n';

    var capitalizeFirstLetterOnly = function( name ) {
        return name[0].toUpperCase() + name.substring( 1, name.length ).toLowerCase();
    };

    var getMappedInterface = function( assignment ) {
        // hack for maxwell
        // return assignment.interfaceName.substring(0, assignment.interfaceName.length-1);
        // hack for maxwell no longer needed
        return assignment.interfaceName;
    };

    var getPeripheralNum = function( assignment ) {
        // Look at the last character in the peripheral name.
        // If it's a number then we use that. Otherwise, use 0.

        var lastChar = parseInt( assignment.peripheral.name[ assignment.peripheral.name.length - 1 ] );
            if( isNaN( lastChar ) ) {
                return 0;
            }
        return lastChar;
    };

    var getMappedPeripheral = function( assignment ) {
        return getMappedInterface( assignment ) + getPeripheralNum( assignment );
    };

    var getPeripheralInstNum = function( assignment ) {
        var optionalParameters = getMappedPeripheral(assignment);
        // Look at the last character in the peripheral name.
        // If it's a number, then we use that.  Otherwise, use 0.
        if(optionalParameters == assignment.interfaceName)
        {
            var lastChar = parseInt( assignment.peripheral.name[ assignment.peripheral.name.length - 1 ] );
        }
        else
        {
            var lastChar = parseInt( optionalParameters[ optionalParameters.length - 1 ] );
        }
        if( isNaN( lastChar ) ) {
            return 0;
        }
        return lastChar;
    };

    var OPT_PARAM = function( assignment ) {
        // optional parameters for pinmuxing
        // For everything, return 0. Not used in Maxwell.

        return 0;
    }

    var PinOptions = function( assignment ) {
        var options = [];
        var notOptions = [];

        var addOption = function( option ) {
            if( option[0] === '~' ) {
                notOptions.push( option );
            } else {
                options.push( option );
            }
        };

        var IS_PULL_ENABLED = function() {
            if( assignment.pu || assignment.pd ) {
                return "~PIN_PULL_DISABLE";
            }
            return "PIN_PULL_DISABLE";
        };

        var PULL_TYPE = function() {
            if( assignment.pu ) {
                return "PIN_PULL_DIRECTION";
            }
            return "~PIN_PULL_DIRECTION";
        };

        var IS_RX_ACTIVE = function() {
            if( assignment.rx || assignment.RX) {
                return "PIN_INPUT_ENABLE";
            }
            return "~PIN_INPUT_ENABLE";
        };

        addOption( IS_PULL_ENABLED() );
        addOption( PULL_TYPE() );
        addOption( IS_RX_ACTIVE() );

        var formatOptions = function( optionsList, operator ) {
            if(optionsList.length == 0) {
                if (operator === " | ") {
                    var result = "(0x50000";
                }
                if (operator === " & ") {
                    var result = "(0x50000";
                }
            }
            else {
                var result = "(";
            }
            for( var i = 0; i < optionsList.length; ++i ) {
                result += optionsList[i];
                if( i != optionsList.length - 1 ) {
                    result += operator;
                }
            }
            result += ")";
            return result;
        };

        this.getOptions = function() {
            return formatOptions( options, " | " );
        }

        this.getNotOptions = function() {
            return formatOptions( notOptions, " & " );
        }
    }

    // First, we need to sort all pin assigments into their mapped interfaces/
    // peripherals.  This mapping isn't what pinmux knows, so we have to do it

    var mappedAssignments = {};
    for( var i = 0; i < assignments.length; ++i ) {
        if( "NOT FOUND" == assignments[i].devicePin.controlRegisterOffset ) {
            // do nothing with pins that have no pad configuration register
        } else {
            var interfaceName = getMappedInterface( assignments[i] );
            var peripheralName = getMappedPeripheral( assignments[i] );
            mappedAssignments[ interfaceName ] = mappedAssignments[ interfaceName ] || {};
            mappedAssignments[ interfaceName ][ peripheralName ] = mappedAssignments[ interfaceName ][ peripheralName ] || [];
            mappedAssignments[ interfaceName ][ peripheralName ].push( assignments[i] );
        }
    }

	var fix_MII_G_RT_muxMode = function ( thisMux ) 
	{
		if (thisMux == 13 || thisMux == 14) 
		{
            return (thisMux - 13);
        } 
        return thisMux;
    };
;
__p += '\n';


   _.each( mappedAssignments, function( peripherals, interfaceName ) {

       _.each( peripherals, function( pins, peripheralName ) {
;
__p += 'static pinmuxPerCfg_t g' +
((__t = (capitalizeFirstLetterOnly( peripheralName ))) == null ? '' : __t) +
'PinCfg[] =\n{\n';

var enumStatements = [];
for( var i = 0; i < pins.length; ++i ) {
    if ( undefined !== pins[i].devicePin.controlRegisterOffset && "NOT FOUND" !== pins[i].devicePin.controlRegisterOffset )
	{
        var pinOptions = new PinOptions( pins[i] );
		if (pins[i].requirementName.includes("MII_G_RT"))
		{
			enumStatements.push(
				{
					line1 : "/* " + pins[i].requirementName + " -> " + pins[i].peripheralPin.name + " -> " + pins[i].devicePin.ball + " */",
					line2 : "{",
					line3 : "    PIN_" + pins[i].devicePin.designSignalName.toUpperCase() + ", " + "PIN_MODE(" + fix_MII_G_RT_muxMode(pins[i].muxMode) + ") | \\",
					line4 : "    (" + pinOptions.getOptions() + " & " + pinOptions.getNotOptions() + ")",
					line5 : "},"
				}
			);
		}
		else
		{
			enumStatements.push(
				{
					line1 : "/* " + pins[i].requirementName + " -> " + pins[i].peripheralPin.name + " -> " + pins[i].devicePin.ball + " */",
					line2 : "{",
					line3 : "    PIN_" + pins[i].devicePin.designSignalName.toUpperCase() + ", " + "PIN_MODE(" + pins[i].muxMode + ") | \\",
					line4 : "    (" + pinOptions.getOptions() + " & " + pinOptions.getNotOptions() + ")",
					line5 : "},"
				}
			);
		}
    }
}
 for( var i = 0; i < enumStatements.length; ++i ) {
;
__p += '    ' +
((__t = (enumStatements[i].line1)) == null ? '' : __t) +
'\n    ' +
((__t = (enumStatements[i].line2)) == null ? '' : __t) +
'\n    ' +
((__t = (enumStatements[i].line3)) == null ? '' : __t) +
'\n    ' +
((__t = (enumStatements[i].line4)) == null ? '' : __t) +
'\n    ' +
((__t = (enumStatements[i].line5)) == null ? '' : __t) +
'\n';
 }
;
__p += '    {PINMUX_END}\n};\n\n';
 });
;
__p += 'static pinmuxModuleCfg_t g' +
((__t = (capitalizeFirstLetterOnly( interfaceName ))) == null ? '' : __t) +
'PinCfg[] =\n{\n';
 _.each( peripherals, function( pins, peripheralName ) {
;
__p += '    {' +
((__t = (getPeripheralInstNum( pins[0] ))) == null ? '' : __t) +
', TRUE, g' +
((__t = (capitalizeFirstLetterOnly( peripheralName ))) == null ? '' : __t) +
'PinCfg},\n';
 });
;
__p += '    {PINMUX_END}\n};\n\n\n';
 });

var enumMainSet = [];
var enumWkupSet = [];
_.each( mappedAssignments, function( pins, interfaceName ) {
    if ( interfaceName.startsWith("WKUP") || interfaceName.startsWith("MCU") ) {
        enumWkupSet.push("g" + capitalizeFirstLetterOnly( interfaceName ) + "PinCfg");
    } else {
        enumMainSet.push("g" + capitalizeFirstLetterOnly( interfaceName ) + "PinCfg");
    }
});
;
__p += 'pinmuxBoardCfg_t gAM243x_ALX_MainPinmuxData[] =\n{\n';
   for( var i = 0; i < enumMainSet.length; ++i ) {
;
__p += '    {' +
((__t = (i)) == null ? '' : __t) +
', ' +
((__t = (enumMainSet[i])) == null ? '' : __t) +
'},\n';
   }
;
__p += '    {PINMUX_END}\n};\n\npinmuxBoardCfg_t gAM243x_ALX_WkupPinmuxData[] =\n{\n';
   for( var i = 0; i < enumWkupSet.length; ++i ) {
;
__p += '    {' +
((__t = (i)) == null ? '' : __t) +
', ' +
((__t = (enumWkupSet[i])) == null ? '' : __t) +
'},\n';
   }
;
__p += '    {PINMUX_END}\n};\n';
return __p
}; });
defineResource("/AM243x_ALX_beta/templates/csv/PinmuxConfigSummary.csv.xdt", function(_, system, pmux, scripting, require) { "use strict";return function(args) {
var __t, __p = '', __j = Array.prototype.join;
function print() { __p += __j.call(arguments, '') }

 var $legacy = pmux.getScript("/legacy/adapt.js")(pmux), assignmentErrors = $legacy.assignmentErrors, assignments = $legacy.assignments;

var fix_MII_G_RT_muxMode = function ( thisMux ) 
{
	var tempMuxMode;
	
	if (thisMux == 13) 
	{
        tempMuxMode = 0;
    }
	else if (thisMux == 14) 
	{
        tempMuxMode = 1;
    }
	else
	{
		tempMuxMode = thisMux;
	}
	
    return ( tempMuxMode ).toString ( 10 );
};

var getRxEnable = function ( assignment ) 
{
    if (assignment.rx !== null) 
	{
        return assignment.rx;
    } 
	else if (assignment.RX !== null) 
	{
        return assignment.RX;
    } 
    return assignment.rx;
};

;
__p += 'Design Signal Pad Name,IO Power Group,PUPD State During HHV,PUPD State After HHV,IO Power Supply Name,IO Power Setting,Required Voltage Level,Ball Name,Selected Mode Number,Mode Interface Name,Mode Signal Name,Mode Type,User Checked PU,User Checked PD,User Checked RX,User Requirement Name\n';
 for( var i = 0; i < assignments.length; ++i ) {
 if( (assignments[i].peripheral.name).includes("_MII") ) {
;
__p +=
((__t = (assignments[i].devicePin.designSignalName)) == null ? '' : __t) +
',' +
((__t = (assignments[i].devicePin.powerDomain.powerGroup)) == null ? '' : __t) +
',' +
((__t = (assignments[i].devicePin.pupdStateDuringHHV)) == null ? '' : __t) +
',' +
((__t = (assignments[i].devicePin.pupdStateAfterHHV)) == null ? '' : __t) +
',' +
((__t = (assignments[i].devicePin.powerDomain.name)) == null ? '' : __t) +
',' +
((__t = (assignments[i].powerSetting)) == null ? '' : __t) +
',' +
((__t = (assignments[i].requiredVoltageLevel)) == null ? '' : __t) +
',' +
((__t = (assignments[i].devicePin.ball)) == null ? '' : __t) +
',' +
((__t = (fix_MII_G_RT_muxMode(assignments[i].muxMode))) == null ? '' : __t) +
',' +
((__t = (assignments[i].peripheral.name)) == null ? '' : __t) +
',' +
((__t = (assignments[i].peripheralPin.name)) == null ? '' : __t) +
',' +
((__t = (assignments[i].peripheralPin.interfacePin.receiver)) == null ? '' : __t) +
',' +
((__t = (assignments[i].pu)) == null ? '' : __t) +
',' +
((__t = (assignments[i].pd)) == null ? '' : __t) +
',' +
((__t = (getRxEnable(assignments[i]))) == null ? '' : __t) +
',' +
((__t = (assignments[i].requirementName)) == null ? '' : __t) +
'\n';
 } 
 else {
;
__p +=
((__t = (assignments[i].devicePin.designSignalName)) == null ? '' : __t) +
',' +
((__t = (assignments[i].devicePin.powerDomain.powerGroup)) == null ? '' : __t) +
',' +
((__t = (assignments[i].devicePin.pupdStateDuringHHV)) == null ? '' : __t) +
',' +
((__t = (assignments[i].devicePin.pupdStateAfterHHV)) == null ? '' : __t) +
',' +
((__t = (assignments[i].devicePin.powerDomain.name)) == null ? '' : __t) +
',' +
((__t = (assignments[i].powerSetting)) == null ? '' : __t) +
',' +
((__t = (assignments[i].requiredVoltageLevel)) == null ? '' : __t) +
',' +
((__t = (assignments[i].devicePin.ball)) == null ? '' : __t) +
',' +
((__t = (assignments[i].muxMode)) == null ? '' : __t) +
',' +
((__t = (assignments[i].peripheral.name)) == null ? '' : __t) +
',' +
((__t = (assignments[i].peripheralPin.name)) == null ? '' : __t) +
',' +
((__t = (assignments[i].peripheralPin.interfacePin.receiver)) == null ? '' : __t) +
',' +
((__t = (assignments[i].pu)) == null ? '' : __t) +
',' +
((__t = (assignments[i].pd)) == null ? '' : __t) +
',' +
((__t = (getRxEnable(assignments[i]))) == null ? '' : __t) +
',' +
((__t = (assignments[i].requirementName)) == null ? '' : __t) +
'\n';
 }}
;

return __p
}; });