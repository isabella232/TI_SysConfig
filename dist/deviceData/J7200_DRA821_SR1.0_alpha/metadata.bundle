// This bundle was auto-generated on 2021-1-5 at 20:17:53
// From the folders: 
// /home/xgbsesvc/jenkins/workspace/sysconfig.build.installers/pinmux/out/dist/deviceData/J7200_DRA821_SR1.0_alpha
defineResource("/J7200_DRA821_SR1.0_alpha/templates/Platform Development Kit (PDK)/J7200_pinmux.h.xdt", function(_, system, pmux, scripting, require) { "use strict";return function(args) {
var __t, __p = '', __j = Array.prototype.join;
function print() { __p += __j.call(arguments, '') }

 var $legacy = pmux.getScript("/legacy/adapt.js")(pmux), assignments = $legacy.assignments;
 var date = new Date();
;
__p += '/**\r\n * Note: This file was auto-generated by TI PinMux on ' +
((__t = (date.toLocaleDateString())) == null ? '' : __t) +
'.\r\n *\r\n * \\file   J7200_pinmux.h\r\n *\r\n * \\brief  This file contains pad configure register offsets and bit-field \r\n *         value macros for different configurations,\r\n *\r\n *           BIT[21]		TXDISABLE		disable the pin\'s output driver\r\n *           BIT[18]		RXACTIVE		enable the pin\'s input buffer (typically kept enabled)\r\n *           BIT[17]		PULLTYPESEL		set the iternal resistor pull direction high or low (if enabled)\r\n *           BIT[16]		PULLUDEN		internal resistor disable (0 = enabled / 1 = disabled)\r\n *           BIT[3:0]		MUXMODE			select the desired function on the given pin\r\n *\r\n *  \\copyright Copyright (CU) ' +
((__t = (date.getFullYear())) == null ? '' : __t) +
' Texas Instruments Incorporated - \r\n *             http://www.ti.com/\r\n */\r\n\r\n#ifndef _J7200_PIN_MUX_H_\r\n#define _J7200_PIN_MUX_H_\r\n\r\n/* ========================================================================== */\r\n/*                             Include Files                                  */\r\n/* ========================================================================== */\r\n\r\n#include "pinmux.h"\r\n#include "csl_types.h"\r\n\r\n#ifdef __cplusplus\r\nextern "C" {\r\n#endif\r\n\r\n/* ========================================================================== */\r\n/*                           Macros & Typedefs                                */\r\n/* ========================================================================== */\r\n#define PIN_MODE(mode)	                (mode)\r\n#define PINMUX_END                      (-1)\r\n\r\n/** \\brief Active mode configurations */\r\n/** \\brief Resistor enable */\r\n#define PIN_PULL_DISABLE                (0x1U << 16U)\r\n/** \\brief Pull direction */\r\n#define	PIN_PULL_DIRECTION              (0x1U << 17U)\r\n/** \\brief Receiver enable */\r\n#define	PIN_INPUT_ENABLE                (0x1U << 18U)\r\n/** \\brief Driver disable */\r\n#define	PIN_OUTPUT_DISABLE              (0x1U << 21U)\r\n/** \\brief Wakeup enable */\r\n#define	PIN_WAKEUP_ENABLE               (0x1U << 29U)\r\n\r\n/** \\brief Pad config register offset in control module */\r\n';

	var enumMainSet = [];
	var enumWkupSet = [];
	
	// exception for pins with no MCU/WKUP domain prefix in the names, they should still go in the Wkup array
	var wkupPinsExc = {
						"TDI" : "", 
						"TDO" : "", 
						"PMIC_POWER_EN1" : "", 
						"TCK" : "",
						"TRSTN" : "",
						"EMU0" : "",
						"EMU1" : "",
						"RESET_REQZ" : "",
						"PORZ" : "",
						"ATEST0" : "",
						"TEMP_DIODE_P" : "",
					}
	
	for( var i = 0; i < assignments.length; ++i ) {
	
		var assignment = assignments[i];
		var interfaceName = assignment.interfaceName;
		var pinName = assignment.devicePin.designSignalName.toUpperCase();
		var s_devicePinNameAndOffset = "PIN_" + pinName + "\t\t = " + assignment.devicePin.controlRegisterOffset+",";
		
		if( assignment.devicePin.controlRegisterOffset !== "NOT FOUND" ) {
			if ( interfaceName.startsWith("WKUP") || interfaceName.startsWith("MCU") || (pinName in wkupPinsExc)) {
				enumWkupSet.push(s_devicePinNameAndOffset);
			} else {
				enumMainSet.push(s_devicePinNameAndOffset);
			}
		}
    }
;
__p += '\r\nenum pinMainOffsets\r\n{\r\n';
for (var i = 0; i < enumMainSet.length; i++){
;
__p += '	' +
((__t = (enumMainSet[i])) == null ? '' : __t) +
'\r\n';
}   
;
__p += '};\r\n\r\nenum pinWkupOffsets\r\n{\r\n';
for (var i = 0; i < enumWkupSet.length; i++){
;
__p += '	' +
((__t = (enumWkupSet[i])) == null ? '' : __t) +
'\r\n';
}
;
__p += '};\r\n\r\n/* ========================================================================== */\r\n/*                            Global Variables                                */\r\n/* ========================================================================== */\r\n\r\n/** \\brief Pinmux configuration data for the board. Auto-generated from \r\n           Pinmux tool. */\r\nextern pinmuxBoardCfg_t gJ7200_MainPinmuxData[];\r\nextern pinmuxBoardCfg_t gJ7200_WkupPinmuxData[];\r\n\r\n#ifdef __cplusplus\r\n}\r\n#endif /* __cplusplus */\r\n#endif /* _J7200_PIN_MUX_H_ */\r\n';
return __p
}; });
defineResource("/J7200_DRA821_SR1.0_alpha/templates/Platform Development Kit (PDK)/J7200_pinmux_data.c.xdt", function(_, system, pmux, scripting, require) { "use strict";return function(args) {
var __t, __p = '', __j = Array.prototype.join;
function print() { __p += __j.call(arguments, '') }

 var $legacy = pmux.getScript("/legacy/adapt.js")(pmux), assignments = $legacy.assignments;
 var date = new Date();
;
__p += '/**\r\n* Note: This file was auto-generated by TI PinMux on ' +
((__t = (date.toLocaleDateString())) == null ? '' : __t) +
' at ' +
((__t = (date.toLocaleTimeString())) == null ? '' : __t) +
'.\r\n*\r\n* \\file  J7200_pinmux_data.c\r\n*\r\n* \\brief  This file contains the pin mux configurations for the boards.\r\n*         These are prepared based on how the peripherals are extended on\r\n*         the boards.\r\n*\r\n* \\copyright Copyright (CU) ' +
((__t = (date.getFullYear())) == null ? '' : __t) +
' Texas Instruments Incorporated -\r\n*             http://www.ti.com/\r\n*/\r\n\r\n/* ========================================================================== */\r\n/*                             Include Files                                  */\r\n/* ========================================================================== */\r\n\r\n#include "J7200_pinmux.h"\r\n\r\n/** Peripheral Pin Configurations */\r\n\r\n';

    var capitalizeFirstLetterOnly = function( name ) {
        return name[0].toUpperCase() + name.substring( 1, name.length ).toLowerCase();
    };

    var getMappedInterface = function( assignment ) {
        // hack for maxwell
        // return assignment.interfaceName.substring(0, assignment.interfaceName.length-1);
        // hack for maxwell no longer needed
        return assignment.interfaceName;
    };

    var getPeripheralNum = function( assignment ) {
        // Look at the last character in the peripheral name.
        // If it's a number then we use that. Otherwise, use 0.

        var lastChar = parseInt( assignment.peripheral.name[ assignment.peripheral.name.length - 1 ] );
            if( isNaN( lastChar ) ) {
                return 0;
            }
        return lastChar;
    };

    var getMappedPeripheral = function( assignment ) {
        return getMappedInterface( assignment ) + getPeripheralNum( assignment );
    };

    var getPeripheralInstNum = function( assignment ) {
        var optionalParameters = getMappedPeripheral(assignment);
        // Look at the last character in the peripheral name.
        // If it's a number, then we use that.  Otherwise, use 0.
        if(optionalParameters == assignment.interfaceName)
        {
            var lastChar = parseInt( assignment.peripheral.name[ assignment.peripheral.name.length - 1 ] );
        }
        else
        {
            var lastChar = parseInt( optionalParameters[ optionalParameters.length - 1 ] );
        }
        if( isNaN( lastChar ) ) {
            return 0;
        }
        return lastChar;
    };

    var OPT_PARAM = function( assignment ) {
        // optional parameters for pinmuxing
        // For everything, return 0. Not used in Maxwell.

        return 0;
    }

    var PinOptions = function( assignment ) {
        var options = [];
        var notOptions = [];

        var addOption = function( option ) {
            if( option[0] === '~' ) {
                notOptions.push( option );
            } else {
                options.push( option );
            }
        };

        var IS_PULL_ENABLED = function() {
            if( assignment.pu || assignment.pd ) {
                return "~PIN_PULL_DISABLE";
            }
            return "PIN_PULL_DISABLE";
        };

        var PULL_TYPE = function() {
            if( assignment.pu ) {
                return "PIN_PULL_DIRECTION";
            }
            return "~PIN_PULL_DIRECTION";
        };

        var IS_RX_ACTIVE = function() {
            if( assignment.rx || assignment.RX) {
                return "PIN_INPUT_ENABLE";
            }
            return "~PIN_INPUT_ENABLE";
        };

        addOption( IS_PULL_ENABLED() );
        addOption( PULL_TYPE() );
        addOption( IS_RX_ACTIVE() );

        var formatOptions = function( optionsList, operator ) {
            if(optionsList.length == 0) {
                if (operator === " | ") {
                    var result = "(0x50000";
                }
                if (operator === " & ") {
                    var result = "(0x50000";
                }
            }
            else {
                var result = "(";
            }
            for( var i = 0; i < optionsList.length; ++i ) {
                result += optionsList[i];
                if( i != optionsList.length - 1 ) {
                    result += operator;
                }
            }
            result += ")";
            return result;
        };

        this.getOptions = function() {
            return formatOptions( options, " | " );
        }

        this.getNotOptions = function() {
            return formatOptions( notOptions, " & " );
        }
    }

    // First, we need to sort all pin assigments into their mapped interfaces/
    // peripherals.  This mapping isn't what pinmux knows, so we have to do it

    var mappedAssignments = {};
    for( var i = 0; i < assignments.length; ++i ) {
        if( "NOT FOUND" == assignments[i].devicePin.controlRegisterOffset ) {
            // do nothing with pins that have no pad configuration register
        } else {
            var interfaceName = getMappedInterface( assignments[i] );
            var peripheralName = getMappedPeripheral( assignments[i] );
            mappedAssignments[ interfaceName ] = mappedAssignments[ interfaceName ] || {};
            mappedAssignments[ interfaceName ][ peripheralName ] = mappedAssignments[ interfaceName ][ peripheralName ] || [];
            mappedAssignments[ interfaceName ][ peripheralName ].push( assignments[i] );
        }
    }

;
__p += '\r\n';


   _.each( mappedAssignments, function( peripherals, interfaceName ) {

       _.each( peripherals, function( pins, peripheralName ) {
;
__p += 'static pinmuxPerCfg_t g' +
((__t = (capitalizeFirstLetterOnly( peripheralName ))) == null ? '' : __t) +
'PinCfg[] =\r\n{\r\n';

var enumStatements = [];
for( var i = 0; i < pins.length; ++i ) {
    if ( undefined !== pins[i].devicePin.controlRegisterOffset && "NOT FOUND" !== pins[i].devicePin.controlRegisterOffset ) {
        var pinOptions = new PinOptions( pins[i] );
        enumStatements.push(
        {
            line1 : "/* " + pins[i].requirementName + " -> " + pins[i].peripheralPin.name + " -> " + pins[i].devicePin.ball + " */",
            line2 : "{",
            line3 : "    PIN_" + pins[i].devicePin.designSignalName.toUpperCase() + ", " + "PIN_MODE(" + pins[i].muxMode + ") | \\",
            line4 : "    (" + pinOptions.getOptions() + " & " + pinOptions.getNotOptions() + ")",
            line5 : "},"
        });
    }
}
 for( var i = 0; i < enumStatements.length; ++i ) {
;
__p += '    ' +
((__t = (enumStatements[i].line1)) == null ? '' : __t) +
'\r\n    ' +
((__t = (enumStatements[i].line2)) == null ? '' : __t) +
'\r\n    ' +
((__t = (enumStatements[i].line3)) == null ? '' : __t) +
'\r\n    ' +
((__t = (enumStatements[i].line4)) == null ? '' : __t) +
'\r\n    ' +
((__t = (enumStatements[i].line5)) == null ? '' : __t) +
'\r\n';
 }
;
__p += '    {PINMUX_END}\r\n};\r\n\r\n';
 });
;
__p += 'static pinmuxModuleCfg_t g' +
((__t = (capitalizeFirstLetterOnly( interfaceName ))) == null ? '' : __t) +
'PinCfg[] =\r\n{\r\n';
 _.each( peripherals, function( pins, peripheralName ) {
;
__p += '    {' +
((__t = (getPeripheralInstNum( pins[0] ))) == null ? '' : __t) +
', TRUE, g' +
((__t = (capitalizeFirstLetterOnly( peripheralName ))) == null ? '' : __t) +
'PinCfg},\r\n';
 });
;
__p += '    {PINMUX_END}\r\n};\r\n\r\n\r\n';
 });

var enumMainSet = [];
var enumWkupSet = [];
_.each( mappedAssignments, function( pins, interfaceName ) {
    if ( interfaceName.startsWith("WKUP") || interfaceName.startsWith("MCU") ) {
        enumWkupSet.push("g" + capitalizeFirstLetterOnly( interfaceName ) + "PinCfg");
    } else {
        enumMainSet.push("g" + capitalizeFirstLetterOnly( interfaceName ) + "PinCfg");
    }
});
;
__p += 'pinmuxBoardCfg_t gJ7200_MainPinmuxData[] =\r\n{\r\n';
   for( var i = 0; i < enumMainSet.length; ++i ) {
;
__p += '    {' +
((__t = (i)) == null ? '' : __t) +
', ' +
((__t = (enumMainSet[i])) == null ? '' : __t) +
'},\r\n';
   }
;
__p += '    {PINMUX_END}\r\n};\r\n\r\npinmuxBoardCfg_t gJ7200_WkupPinmuxData[] =\r\n{\r\n';
   for( var i = 0; i < enumWkupSet.length; ++i ) {
;
__p += '    {' +
((__t = (i)) == null ? '' : __t) +
', ' +
((__t = (enumWkupSet[i])) == null ? '' : __t) +
'},\r\n';
   }
;
__p += '    {PINMUX_END}\r\n};\r\n';
return __p
}; });
defineResource("/J7200_DRA821_SR1.0_alpha/templates/csv/PinmuxConfigSummary.csv.xdt", function(_, system, pmux, scripting, require) { "use strict";return function(args) {
var __t, __p = '', __j = Array.prototype.join;
function print() { __p += __j.call(arguments, '') }

 var $legacy = pmux.getScript("/legacy/adapt.js")(pmux), assignmentErrors = $legacy.assignmentErrors, assignments = $legacy.assignments;

var parseMux = function ( thisMux ) {
    if (thisMux > 14) {
        return thisMux;
    } else if (thisMux > 10) {
        return 1;
    } else if (thisMux > 7) {
        return 0;
    }
    return thisMux;
	
};

var getRxEnable = function ( assignment ) {
	
    if (assignment.rx !== null) {
        return assignment.rx;
    } else if (assignment.RX !== null) {
        return assignment.RX;
    } 
	
	
    return assignment.rx;
};

;
__p += 'Design Signal Pad Name,IO Power Group,PUPD State During HHV,PUPD State After HHV,IO Power Supply Name,IO Power Setting,Required Voltage Level,Ball Name,Selected Mode Number,Mode Interface Name,Mode Signal Name,Mode Type,User Checked PU,User Checked PD,User Checked RX,User Requirement Name\r\n';
 for( var i = 0; i < assignments.length; ++i ) {
;
__p +=
((__t = (assignments[i].devicePin.designSignalName)) == null ? '' : __t) +
',' +
((__t = (assignments[i].devicePin.powerDomain.powerGroup)) == null ? '' : __t) +
',' +
((__t = (assignments[i].devicePin.pupdStateDuringHHV)) == null ? '' : __t) +
',' +
((__t = (assignments[i].devicePin.pupdStateAfterHHV)) == null ? '' : __t) +
',' +
((__t = (assignments[i].devicePin.powerDomain.name)) == null ? '' : __t) +
',' +
((__t = (assignments[i].powerSetting)) == null ? '' : __t) +
',' +
((__t = (assignments[i].requiredVoltageLevel)) == null ? '' : __t) +
',' +
((__t = (assignments[i].devicePin.ball)) == null ? '' : __t) +
',' +
((__t = (assignments[i].muxMode)) == null ? '' : __t) +
',' +
((__t = (assignments[i].peripheral.name)) == null ? '' : __t) +
',' +
((__t = (assignments[i].peripheralPin.name)) == null ? '' : __t) +
',' +
((__t = (assignments[i].peripheralPin.interfacePin.receiver)) == null ? '' : __t) +
',' +
((__t = (assignments[i].pu)) == null ? '' : __t) +
',' +
((__t = (assignments[i].pd)) == null ? '' : __t) +
',' +
((__t = (getRxEnable(assignments[i]))) == null ? '' : __t) +
',' +
((__t = (assignments[i].requirementName)) == null ? '' : __t) +
'\r\n';
 }
;

return __p
}; });
defineResource("/J7200_DRA821_SR1.0_alpha/templates/linux/devicetree.dtsi.xdt", function(_, system, pmux, scripting, require) { "use strict";return function(args) {
var __t, __p = '', __j = Array.prototype.join;
function print() { __p += __j.call(arguments, '') }

 var $legacy = pmux.getScript("/legacy/adapt.js")(pmux), assignments = $legacy.assignments;

var groupedAssignmentsMAIN = {};
var groupedAssignmentsWKUP = {};
var notUsedAssignments = {};

_( assignments ).each( function( assignment ) {

	// exception for pins with no MCU/WKUP domain prefix in the names, they should still go in the Wkup array
	var wkupPinsExc = {
						"TDI" : "", 
						"TDO" : "", 
						"PMIC_POWER_EN1" : "", 
						"TCK" : "",
						"TRSTN" : "",
						"EMU0" : "",
						"EMU1" : "",
						"RESET_REQZ" : "",
						"PORZ" : "",
						"ATEST0" : "",
						"TEMP_DIODE_P" : "",
					}
					
	// Use the requirement name as the name, but lower case and _ instead of spaces
	var requirementName = assignment.requirementName.toLowerCase().replace( / /g, "_" );
	if( "NOT FOUND" !== assignment.devicePin.controlRegisterOffset ) {
		if ( _.includes(assignment.interfaceName, "WKUP") || _.includes(assignment.interfaceName, "MCU") || (assignment.devicePin.designSignalName.toUpperCase() in wkupPinsExc)) {
			groupedAssignmentsWKUP[ assignment.interfaceName ] = groupedAssignmentsWKUP[ assignment.interfaceName ] || {};
			groupedAssignmentsWKUP[ assignment.interfaceName ][ requirementName ] = groupedAssignmentsWKUP[ assignment.interfaceName ][ requirementName ] || [];
			groupedAssignmentsWKUP[ assignment.interfaceName ][ requirementName ].push( assignment );
		} else {
			groupedAssignmentsMAIN[ assignment.interfaceName ] = groupedAssignmentsMAIN[ assignment.interfaceName ] || {};
			groupedAssignmentsMAIN[ assignment.interfaceName ][ requirementName ] = groupedAssignmentsMAIN[ assignment.interfaceName ][ requirementName ] || [];
			groupedAssignmentsMAIN[ assignment.interfaceName ][ requirementName ].push( assignment );
		}
	} else {
		notUsedAssignments[ assignment.interfaceName ] = notUsedAssignments[ assignment.interfaceName ] || {};
		notUsedAssignments[ assignment.interfaceName ][ requirementName ] = {};
	}
} );

var getOffset = function( assignment ) {
	return ( assignment.devicePin.controlRegisterOffset ).toString( 16 ).toLowerCase();
};

var getPinConfig = function( assignment ) {
	var result = "";
	
	if( assignment.rx || assignment.RX) {
		if( assignment.pu ) {
			result += "PIN_INPUT_PULLUP";
		}
		else if( assignment.pd ) {
			result += "PIN_INPUT_PULLDOWN";
		}
		else {
			result += "PIN_INPUT";
		}
	} else {
		if( assignment.pu ) {
			result += "PIN_OUTPUT_PULLUP";
		}
		else if( assignment.pd ) {
			result += "PIN_OUTPUT_PULLDOWN";
		}
		else {
			result += "PIN_OUTPUT";
		}
	}
	return result;
};

var getPinMuxMode = function( assignment ) {
	return ( assignment.muxMode ).toString ( 10 );
};

var getPinComment = function( assignment ) {
	if (assignment.devicePin.designSignalName == assignment.peripheralPin.name) {
		return "/* (" + assignment.devicePin.ball + ") " + assignment.devicePin.designSignalName + " */";
	} else {
		return "/* (" + assignment.devicePin.ball + ") " + assignment.devicePin.designSignalName + "." + assignment.peripheralPin.name + " */";
	}
};

var date = new Date();

;
__p += '/* This file was auto-generated by TI PinMux on ' +
((__t = (date.toLocaleDateString())) == null ? '' : __t) +
' at ' +
((__t = (date.toLocaleTimeString())) == null ? '' : __t) +
'. */\r\n/* This file should only be used as a reference. Some pins/peripherals, */\r\n/* depending on your use case, may need additional configuration. */\r\n\r\n';
 if( !_( notUsedAssignments ).isEmpty() ) {
;
__p += '/* Some or all of the pins from the following groups are not used by the device tree\r\n';
	_( notUsedAssignments ).each( function( iFace ) {
		_( iFace ).each( function( requirement, requirementName ) {
;
__p += '	' +
((__t = (requirementName)) == null ? '' : __t) +
'\r\n';
		} );
	} );
;
__p += '*/\r\n\r\n';
 }
 if( !_( groupedAssignmentsMAIN ).isEmpty() ) {
;
__p += '&main_pmx0 {\r\n';
	_( groupedAssignmentsMAIN ).each( function( iFace ) {
		_( iFace ).each( function( requirement, requirementName ) {
;
__p += '	' +
((__t = (requirementName)) == null ? '' : __t) +
'_pins_default: ' +
((__t = (requirementName)) == null ? '' : __t) +
'_pins_default {\r\n		pinctrl-single,pins = <\r\n';
			_( requirement ).each( function( assignment ) {
;
__p += '			J7200_IOPAD(' +
((__t = (getOffset( assignment ))) == null ? '' : __t) +
', ' +
((__t = (getPinConfig( assignment ))) == null ? '' : __t) +
', ' +
((__t = (getPinMuxMode( assignment ))) == null ? '' : __t) +
') ' +
((__t = (getPinComment( assignment ))) == null ? '' : __t) +
'\r\n';
			} );
;
__p += '		>;\r\n	};\r\n\r\n';
		} );
	} );
;
__p += '};\r\n\r\n';
 }
 if( !_( groupedAssignmentsWKUP ).isEmpty() ) {
;
__p += '&wkup_pmx0 {\r\n';
	_( groupedAssignmentsWKUP ).each( function( iFace ) {
		_( iFace ).each( function( requirement, requirementName ) {
;
__p += '	' +
((__t = (requirementName)) == null ? '' : __t) +
'_pins_default: ' +
((__t = (requirementName)) == null ? '' : __t) +
'_pins_default {\r\n		pinctrl-single,pins = <\r\n';
			_( requirement ).each( function( assignment ) {
;
__p += '			J7200_WKUP_IOPAD(' +
((__t = (getOffset( assignment ))) == null ? '' : __t) +
', ' +
((__t = (getPinConfig( assignment ))) == null ? '' : __t) +
', ' +
((__t = (getPinMuxMode( assignment ))) == null ? '' : __t) +
') ' +
((__t = (getPinComment( assignment ))) == null ? '' : __t) +
'\r\n';
			} );
;
__p += '		>;\r\n	};\r\n\r\n';
		} );
	} );
;
__p += '};\r\n';
 }
;

return __p
}; });