// This bundle was auto-generated on 2021-1-5 at 20:17:42
// From the folders: 
// /home/xgbsesvc/jenkins/workspace/sysconfig.build.installers/pinmux/out/dist/deviceData/66AK2G01
defineResource("/66AK2G01/templates/Platform Development Kit (PDK)/66AK2G0x_pinmux.h.xdt", function(_, system, pmux, scripting, require) { "use strict";return function(args) {
var __t, __p = '', __j = Array.prototype.join;
function print() { __p += __j.call(arguments, '') }

 var $legacy = pmux.getScript("/legacy/adapt.js")(pmux), deviceData = $legacy.deviceData;
 var date = new Date();
;
__p += '/**\n * Note: This file was auto-generated by TI PinMux on ' +
((__t = (date.toLocaleDateString())) == null ? '' : __t) +
' at ' +
((__t = (date.toLocaleTimeString())) == null ? '' : __t) +
'.\n *\n * \\file   66AK2G0x_pinmux.h\n *\n * \\brief  This file contains pad configure register offsets and bit-field \n *         value macros for different configurations,\n *\n *           18   RXACTIVE       Not used in K2G, make sure = 1 anyway\n *           17   PULLTYPESEL    Pad pullup/pulldown type selection\n *           16   PULLUDEN       Pad Pullup/pulldown enable\n *           3:0  MUXMODE        Pad functional signal mux select\n *\n *  \\copyright Copyright (CU) ' +
((__t = (date.getFullYear())) == null ? '' : __t) +
' Texas Instruments Incorporated - \n *             http://www.ti.com/\n */\n\n#ifndef _66AK2G0X_PIN_MUX_H_\n#define _66AK2G0X_PIN_MUX_H_\n\n/* ========================================================================== */\n/*                             Include Files                                  */\n/* ========================================================================== */\n\n#include "pinmux.h"\n\n#ifdef __cplusplus\nextern "C" {\n#endif\n\n/* ========================================================================== */\n/*                           Macros & Typedefs                                */\n/* ========================================================================== */\n#define PIN_MODE(mode)	                (mode)\n\n/** \\brief Active mode configurations */\n/** \\brief Pull up/down disabled */\n#define PIN_PULL_UD_EN	                (0x1U << 16U)  \n/** \\brief Pull UP enable */\n#define	PIN_PULL_TYPE_SEL	            (0x1U << 17U)\n\n\n/** \\brief Pad config register offset in control module */\nenum pinOffsets\n{\n';

	var enumStatements = [];	
	_.each( deviceData.devicePins, function( devicePin ) {
		if( undefined !== devicePin.controlRegisterOffset && "NOT FOUND" !== devicePin.controlRegisterOffset ) {
			enumStatements.push( { value : devicePin.controlRegisterOffset + "U", name : "PIN_" + devicePin.designSignalName.toUpperCase() } );
		}
	} );
	enumStatements = _.sortBy( enumStatements, function( statement ) { return statement.value; } );
	var spaces = function( number ) {
		var text = "";
		for( var i = 25 - number; i > 0; --i ) {
			text += " ";
		}
		return text;
	}
;
__p += '	PIN_OFFSET_MIN ' +
((__t = (spaces( "PIN_OFFSET_MIN".length ))) == null ? '' : __t) +
' = ' +
((__t = (enumStatements[ 0 ].value)) == null ? '' : __t) +
',\n';
	for( var i = 0; i < enumStatements.length; ++i ) {
;
__p += '	' +
((__t = (enumStatements[i].name)) == null ? '' : __t) +
' ' +
((__t = (spaces( enumStatements[i].name.length ))) == null ? '' : __t) +
' = ' +
((__t = (enumStatements[i].value)) == null ? '' : __t) +
',\n';
	}
;
__p += '	PIN_OFFSET_MAX ' +
((__t = (spaces( "PIN_OFFSET_MAX".length ))) == null ? '' : __t) +
' = ' +
((__t = (enumStatements[ enumStatements.length - 1 ].value)) == null ? '' : __t) +
'\n};\n\n\n/* ========================================================================== */\n/*                            Global Variables                                */\n/* ========================================================================== */\n\n/** \\brief Pinmux configuration data for the board. Auto-generated from \n           Pinmux tool. */\nextern pinmuxBoardCfg_t gK2G0xPinmuxData[];\n\n#ifdef __cplusplus\n}\n#endif /* __cplusplus */\n#endif /* _66AK2G0X_PIN_MUX_H_ */\n';
return __p
}; });
defineResource("/66AK2G01/templates/Platform Development Kit (PDK)/66AK2G0x_pinmux_data.c.xdt", function(_, system, pmux, scripting, require) { "use strict";return function(args) {
var __t, __p = '', __j = Array.prototype.join;
function print() { __p += __j.call(arguments, '') }

 var $legacy = pmux.getScript("/legacy/adapt.js")(pmux), assignments = $legacy.assignments;
 var date = new Date();
;
__p += '/**\n * Note: This file was auto-generated by TI PinMux on ' +
((__t = (date.toLocaleDateString())) == null ? '' : __t) +
' at ' +
((__t = (date.toLocaleTimeString())) == null ? '' : __t) +
'.\n *\n * \\file  66AK2G0x_pinmux_data.c\n *\n * \\brief  This file contains the pin mux configurations for the boards.\n *         These are prepared based on how the peripherals are extended on\n *         the boards.\n *\n * \\copyright Copyright (CU) ' +
((__t = (date.getFullYear())) == null ? '' : __t) +
' Texas Instruments Incorporated -\n *             http://www.ti.com/\n */\n\n/* ========================================================================== */\n/*                             Include Files                                  */\n/* ========================================================================== */\n/* #include "csl_types.h" */\n#include "types.h"\n#include "pinmux.h"\n#include "66AK2G0x_pinmux.h"\n\n/** Peripheral Pin Configurations */\n\n';

var capitalizeFirstLetterOnly = function( name ) {
    return name[0].toUpperCase() + name.substring( 1, name.length ).toLowerCase();
};

var getMappedInterface = function( assignment ) {
    // The PRU-ICSS is named along with the sub module name. Eg: PRU-ICSS1_MII0,
    // PRU-ICSS1_ECAT, PRU-ICSS1_CAP0 etc… So where ever you have “PRU-ICSS” as
    // substring the module is just PRU_ICSS

    if( -1 !== assignment.interfaceName.indexOf( "PRU-ICSS" ) ) {
        return "PRU_ICSS";
    }

    // The PWMSS is named only with sub-module names (unlike PRUSS case).
    // Eg: eCAP0, eQEP2, eHRPWM2 etc…. So where ever you are seeing eCAP, eQEP,
    // eHRPWM without PRUSS substring they belong to PWMSS.

    switch( assignment.interfaceName ) {
        case "eCAP":
        case "eQEP":
        case "eHRPWM":
            return "PWMSS";

        case "RGMII":
        case "RGMII1":
        case "RGMII2":
        case "RMII":
        case "RMII1":
        case "RMII2":
        case "MII":
        case "MII1":
        case "MII2":
        case "MDIO":
            return "CPSW";

        case "MMC":
            return "MMCSD";

        case "SPI":
            return "MCSPI";

        default:
            return assignment.interfaceName;
    }
};

var getPeripheralNum = function( assignment ) {
    // MII1_PRUSS is currently an exception.  We probably should have a
    // MII_PRUSS interface with two peripherals.

    if( assignment.interfaceName == "MII1_PRUSS" ) {
        return 1;
    }

    // Look at the last character in the peripheral name.
    // If it's a number then we use that. Otherwise, use 0.

    var lastChar = parseInt( assignment.peripheral.name[ assignment.peripheral.name.length - 1 ] );
    if( isNaN( lastChar ) ) {
        return 0;
    }
    return lastChar;
};

var getMappedPeripheral = function( assignment ) {

    switch( assignment.interfaceName ) {
        case "RGMII":
        case "RGMII1":
        case "RGMII2":
        case "RMII":
        case "RMII1":
        case "RMII2":
        case "MII":
        case "MII1":
        case "MII2":
        case "MDIO":
            return getMappedInterface( assignment ) + "0";

        default:
            return getMappedInterface( assignment ) + getPeripheralNum( assignment );
    }
};

var getPeripheralInstNum = function( assignment ) {
    // MII1_PRUSS is currently an exception.  We probably should have a
    // MII_PRUSS interface with two peripherals.

    if( assignment.interfaceName == "MII1_PRUSS" ) {
        return 1;
    }

    var optionalParameters = getMappedPeripheral(assignment);

    // Otherwise, look at the last character in the peripheral name.  If it's a
    // number, then we use that.  Otherwise, use 0
    if(optionalParameters == assignment.interfaceName)
    {
        var lastChar = parseInt( assignment.peripheral.name[ assignment.peripheral.name.length - 1 ] );
    }
    else
    {
        var lastChar = parseInt( optionalParameters[ optionalParameters.length - 1 ] );
    }
    if( isNaN( lastChar ) ) {
        return 0;
    }
    return lastChar;
};

var OPT_PARAM = function( assignment ) {

    // optional parameters for pinmuxing
    // For everything, return 0. Not used in K2G.

    return 0;
}

var PinOptions = function( assignment ) {
    var options = [];
    var notOptions = [];

    var addOption = function( option ) {
        if( option[0] === '~' ) {
            notOptions.push( option );
        } else {
            options.push( option );
        }
    };

    var IS_PULL_ENABLED = function() {
        if( assignment.pu || assignment.pd ) {
            return "~PIN_PULL_UD_EN";
        }
        return "PIN_PULL_UD_EN";
    };

    var PULL_TYPE = function() {
        if( assignment.pu ) {
            return "PIN_PULL_TYPE_SEL";
        }
        return "~PIN_PULL_TYPE_SEL";
    };

	/*
    var IS_RX_ACTIVE = function() {
        if( assignment.rx ) {
            return "PIN_RX_ACTIVE";
        }
        return "~PIN_RX_ACTIVE";
    };
	*/

    addOption( IS_PULL_ENABLED() );
    addOption( PULL_TYPE() );
    // addOption( IS_RX_ACTIVE() );

    var formatOptions = function( optionsList, operator ) {
    if(optionsList.length == 0) {
        if (operator === " | ") {
            var result = "(0x70000";
        }
        if (operator === " & ") {
            var result = "(0x70000";
        }
    }
    else {
        var result = "(";
    }
        for( var i = 0; i < optionsList.length; ++i ) {
            result += optionsList[i];
            if( i != optionsList.length - 1 ) {
                result += operator;
            }
        }
        result += ")";
        return result;
    };

    this.getOptions = function() {
        return formatOptions( options, " | " );
    }

    this.getNotOptions = function() {

        return formatOptions( notOptions, " & " );
    }
}

var pru0GpioUsed = false;
var pru1GpioUsed = false;
var pru0WrapperUsed = false;
var pru1WrapperUsed = false;
function checkPRUICSSInternalWrapper ( peripheralName ) {
	var pru0 = {
		"PRU-ICSS0_PRU0" : "",
		"PRU-ICSS0_PRU1" : ""
	};
	var pru1 = {
		"PRU-ICSS0_PRU0" : "",
		"PRU-ICSS0_PRU1" : ""
	};

	if (peripheralName == "PRU-ICSS0_MII")
		pru0WrapperUsed = true;
	else if (peripheralName == "PRU-ICSS1_MII")
		pru1WrapperUsed = true;
	else if (peripheralName in pru0)
		pru0GpioUsed = true;
	else if (peripheralName in pru1)
		pru1GpioUsed = true;

	if (( pru0WrapperUsed && pru0GpioUsed ) || ( pru1WrapperUsed && pru1GpioUsed )) {
		var pruErrorMessage = "\n\/*\nWhen the PRU-ICSS_MII pins are selected, the PRU-ICSS internal wrapper multiplexing\n"
		+ "must be configured for PRU-ICSS_MII functionality (or MII mode). In this configuration,\n"
		+ "the PRU peripherals listed below are not available for any other I/O functionality and\n"
		+ "cannot be selected in the PMT. See the device TRM for more details.\n\n"
		+ "\t•\tAny PRU-ICSS0_MIIx pins selected: PRU-ICSS0_PRU0 and PRU-ICSS0_PRU1 cannot be used.\n"
		+ "\t•\tAny PRU-ICSS1_MIIx pins selected: PRU-ICSS1_PRU0 and PRU-ICSS1_PRU1 cannot be used.\n*\/"
		throw new Error( pruErrorMessage );
	}

};

// First, we need to sort all pin assignments into their mapped interfaces/
// peripherals.  This mapping isn't what pinmux knows, so we have to do it

var mappedAssignments = {};
for( var i = 0; i < assignments.length; ++i ) {
	if ( assignments[i].devicePin.controlRegisterOffset === "NOT FOUND" ) {
		// do nothing with assignments that have no pad config register
	} else {
		checkPRUICSSInternalWrapper(assignments[i].peripheral.name);
		var interfaceName = getMappedInterface( assignments[i] );
		var peripheralName = getMappedPeripheral( assignments[i] );
		mappedAssignments[ interfaceName ] = mappedAssignments[ interfaceName ] || {};
		mappedAssignments[ interfaceName ][ peripheralName ] = mappedAssignments[ interfaceName ][ peripheralName ] || [];
		mappedAssignments[ interfaceName ][ peripheralName ].push( assignments[i] );
	}
}

var parseMux = function ( thisMux ) {
	if (thisMux > 9) {
		thisMux = 1;
	} else if (thisMux > 5) {
		thisMux = 0;
	}
	return thisMux;
};

 _.each( mappedAssignments, function( peripherals, interfaceName ) {
;
__p += '#ifndef BUILDCFG_MOD_' +
((__t = (interfaceName.toUpperCase())) == null ? '' : __t) +
'\n#define BUILDCFG_MOD_' +
((__t = (interfaceName.toUpperCase())) == null ? '' : __t) +
'\n#endif /* BUILDCFG_MOD_' +
((__t = (interfaceName.toUpperCase())) == null ? '' : __t) +
' */\n\n';
 } );
;
__p += '\n';
 _.each( mappedAssignments, function( peripherals, interfaceName ) {
;
__p += '#if defined(BUILDCFG_MOD_' +
((__t = (interfaceName.toUpperCase())) == null ? '' : __t) +
')\n\n';
   _.each( peripherals, function( pins, peripheralName ) {
;
__p += 'static pinmuxPerCfg_t g' +
((__t = (capitalizeFirstLetterOnly( peripheralName ))) == null ? '' : __t) +
'PinCfg[] =\n{\n';

	var enumStatements = [];
		for( var i = 0; i < pins.length; ++i ) {
            if( undefined == pins[i].devicePin.controlRegisterOffset || "NOT FOUND" == pins[i].devicePin.controlRegisterOffset ) {
            }
            else {
				var pinOptions = new PinOptions( pins[i] );
    enumStatements.push({line1 : "{",
        line2 : "   /* " + pins[i].requirementName + " -> " + pins[i].peripheralPin.name + " -> " + pins[i].devicePin.ball + " */",
        line3 : "   PIN_" + pins[i].devicePin.designSignalName.toUpperCase() + ", " + OPT_PARAM( pins[i] ) + ", \\",
        line4 : "   ( \\",
        line5 : "       PIN_MODE(" + parseMux(pins[i].muxMode) + ") | \\",
        line6 : "       (" + pinOptions.getOptions() + " & " + pinOptions.getNotOptions() + ") \\",
        line7 : "   ) \\",
        line8 : "},"});
            }
       }
   for( var i = 0; i < enumStatements.length; ++i ) {
;
__p += '    ' +
((__t = (enumStatements[i].line1)) == null ? '' : __t) +
'\n    ' +
((__t = (enumStatements[i].line2)) == null ? '' : __t) +
'\n    ' +
((__t = (enumStatements[i].line3)) == null ? '' : __t) +
'\n    ' +
((__t = (enumStatements[i].line4)) == null ? '' : __t) +
'\n    ' +
((__t = (enumStatements[i].line5)) == null ? '' : __t) +
'\n    ' +
((__t = (enumStatements[i].line6)) == null ? '' : __t) +
'\n    ' +
((__t = (enumStatements[i].line7)) == null ? '' : __t) +
'\n    ' +
((__t = (enumStatements[i].line8)) == null ? '' : __t) +
'\n';
   }
;
__p += '    {PINMUX_INVALID_PIN}\n};\n\n';
   } );
;
__p += 'static pinmuxModuleCfg_t g' +
((__t = (capitalizeFirstLetterOnly( interfaceName ))) == null ? '' : __t) +
'PinCfg[] =\n{\n';
   _.each( peripherals, function( pins, peripheralName ) {
;
__p += '    {' +
((__t = (getPeripheralInstNum( pins[0] ))) == null ? '' : __t) +
', TRUE, g' +
((__t = (capitalizeFirstLetterOnly( peripheralName ))) == null ? '' : __t) +
'PinCfg},\n';
   } );
;
__p += '    {CHIPDB_INVALID_INSTANCE_NUM}\n};\n\n#endif /* if defined(BUILDCFG_MOD_' +
((__t = (interfaceName.toUpperCase())) == null ? '' : __t) +
') */\n\n';
 } );
;
__p += '\n\npinmuxBoardCfg_t gK2G0xPinmuxData[] =\n{\n';
 _.each( mappedAssignments, function( iface, interfaceName ) {
;
__p += '#if defined(BUILDCFG_MOD_' +
((__t = (interfaceName.toUpperCase())) == null ? '' : __t) +
')\n    {CHIPDB_MOD_ID_' +
((__t = (interfaceName.toUpperCase())) == null ? '' : __t) +
', g' +
((__t = (capitalizeFirstLetterOnly(interfaceName))) == null ? '' : __t) +
'PinCfg},\n#endif /* if defined(BUILDCFG_MOD_' +
((__t = (interfaceName.toUpperCase())) == null ? '' : __t) +
') */\n';
 } );
;
__p += '    {CHIPDB_MOD_ID_INVALID}\n};\n';
return __p
}; });
defineResource("/66AK2G01/templates/csv/PinmuxConfigSummary.csv.xdt", function(_, system, pmux, scripting, require) { "use strict";return function(args) {
var __t, __p = '', __j = Array.prototype.join;
function print() { __p += __j.call(arguments, '') }

 var $legacy = pmux.getScript("/legacy/adapt.js")(pmux), assignments = $legacy.assignments;


var parseMux = function ( thisMux ) {
	if (thisMux > 9) {
		thisMux = 1;
	} else if (thisMux > 5) {
		thisMux = 0;
	}
	return thisMux;
};

var pru0GpioUsed = false;
var pru1GpioUsed = false;
var pru0WrapperUsed = false;
var pru1WrapperUsed = false;
function checkPRUICSSInternalWrapper ( peripheralName ) {
	var pru0 = {
		"PRU-ICSS0_PRU0" : "",
		"PRU-ICSS0_PRU1" : ""
	};
	var pru1 = {
		"PRU-ICSS0_PRU0" : "",
		"PRU-ICSS0_PRU1" : ""
	};

	if (peripheralName == "PRU-ICSS0_MII")
		pru0WrapperUsed = true;
	else if (peripheralName == "PRU-ICSS1_MII")
		pru1WrapperUsed = true;
	else if (peripheralName in pru0)
		pru0GpioUsed = true;
	else if (peripheralName in pru1)
		pru1GpioUsed = true;

	if (( pru0WrapperUsed && pru0GpioUsed ) || ( pru1WrapperUsed && pru1GpioUsed )) {
		var pruErrorMessage = "\n\/*\nWhen the PRU-ICSS_MII pins are selected, the PRU-ICSS internal wrapper multiplexing\n"
		+ "must be configured for PRU-ICSS_MII functionality (or MII mode). In this configuration,\n"
		+ "the PRU peripherals listed below are not available for any other I/O functionality and\n"
		+ "cannot be selected in the PMT. See the device TRM for more details.\n\n"
		+ "\t•\tAny PRU-ICSS0_MIIx pins selected: PRU-ICSS0_PRU0 and PRU-ICSS0_PRU1 cannot be used.\n"
		+ "\t•\tAny PRU-ICSS1_MIIx pins selected: PRU-ICSS1_PRU0 and PRU-ICSS1_PRU1 cannot be used.\n*\/"
		throw new Error( pruErrorMessage );
	}

	return peripheralName;
};

;
__p += 'Design Signal Pad Name,IO Power Group,PUPD State During HHV,PUPD State After HHV,IO Power Supply Name,IO Power Setting,Required Voltage Level,Ball Name,Selected Mode Number,Mode Interface Name,Mode Signal Name,Mode Type,User Checked PU,User Checked PD,User Checked RX,User Requirement Name\r\n';
 for( var i = 0; i < assignments.length; ++i ) {
;
__p +=
((__t = (assignments[i].devicePin.designSignalName)) == null ? '' : __t) +
',' +
((__t = (assignments[i].devicePin.powerDomain.powerGroup)) == null ? '' : __t) +
',' +
((__t = (assignments[i].devicePin.pupdStateDuringHHV)) == null ? '' : __t) +
',' +
((__t = (assignments[i].devicePin.pupdStateAfterHHV)) == null ? '' : __t) +
',' +
((__t = (assignments[i].devicePin.powerDomain.name)) == null ? '' : __t) +
',' +
((__t = (assignments[i].powerSetting)) == null ? '' : __t) +
',' +
((__t = (assignments[i].requiredVoltageLevel)) == null ? '' : __t) +
',' +
((__t = (assignments[i].devicePin.ball)) == null ? '' : __t) +
',' +
((__t = (parseMux(assignments[i].muxMode))) == null ? '' : __t) +
',' +
((__t = (checkPRUICSSInternalWrapper(assignments[i].peripheral.name))) == null ? '' : __t) +
',' +
((__t = (assignments[i].peripheralPin.name)) == null ? '' : __t) +
',' +
((__t = (assignments[i].peripheralPin.interfacePin.receiver)) == null ? '' : __t) +
',' +
((__t = (assignments[i].pu)) == null ? '' : __t) +
',' +
((__t = (assignments[i].pd)) == null ? '' : __t) +
',' +
((__t = (assignments[i].rx)) == null ? '' : __t) +
',' +
((__t = (assignments[i].requirementName)) == null ? '' : __t) +
'\r\n';
 }
;

return __p
}; });
defineResource("/66AK2G01/templates/linux/devicetree.dtsi.xdt", function(_, system, pmux, scripting, require) { "use strict";return function(args) {
var __t, __p = '', __j = Array.prototype.join;
function print() { __p += __j.call(arguments, '') }

 var $legacy = pmux.getScript("/legacy/adapt.js")(pmux), assignments = $legacy.assignments;
 var date = new Date();
;
__p += '/**\n * Note: This file was auto-generated by TI PinMux on ' +
((__t = (date.toLocaleDateString())) == null ? '' : __t) +
' at ' +
((__t = (date.toLocaleTimeString())) == null ? '' : __t) +
'.\n *\n * \\file devicetree.dtsi\n *\n * \\brief This file contains BOOT_CFG register configurations in an \n * includable device tree (.dtsi) format. For summarization and description\n * of the pad register bits refer to the "Pad Configuration Registers"\n * sub-section of the device Data Manual. This file should only be used as\n * a reference. Some pins and/or peripherals, depending on the use case, \n * may need additional configuration.\n *\n * \\copyright Copyright (CU) ' +
((__t = (date.getFullYear())) == null ? '' : __t) +
' Texas Instruments Incorporated - \n *             http://www.ti.com/\n */\n';


var getAddress = function( assignment ) {
	return ( assignment.devicePin.controlRegisterOffset).toString( 16 ).toLowerCase();
};

// function read the properties of the UI configuration and return a device tree string
var getDeviceTreeString = function ( assignment ){

	//MUXMODE
	// handle PRUSS / ICSS virtual muxing
	var thisMux = assignment.muxMode;
	if (thisMux > 9) {
		thisMux = 1;
	} else if (thisMux > 5) {
		thisMux = 0;
	}

	var MUXMODE = "MUX_MODE" + thisMux;
	var deviceTreeRegValueString = MUXMODE;

	//PULL UP/DOWN
	if(assignment.nopull === true){
		deviceTreeRegValueString = "PULL_DISABLE | " + deviceTreeRegValueString;
	}else{
		if(assignment.pd === true){
			deviceTreeRegValueString = "PIN_PULLDOWN | " + deviceTreeRegValueString;
		}else{
			deviceTreeRegValueString = "PIN_PULLUP | " + deviceTreeRegValueString;
		}
	}

	//BUFFER CLASS
	if (!_.isEmpty(assignment.configurables)) {

		var bufferClassString = assignment.configurables.buffer_class.name;
		bufferClassString = (bufferClassString.replace("class", "")).toUpperCase();
		
		var buffClassTypes = {"B":"" , "C":"" , "D":"", "E":""};
		if(bufferClassString in buffClassTypes){
			deviceTreeRegValueString = "BUFFER_CLASS_" + bufferClassString + " | " + deviceTreeRegValueString;
		}

	}

	return deviceTreeRegValueString;
};

var pru0GpioUsed = false;
var pru1GpioUsed = false;
var pru0WrapperUsed = false;
var pru1WrapperUsed = false;
function checkPRUICSSInternalWrapper ( peripheralName ) {
	var pru0 = {
		"PRU-ICSS0_PRU0" : "",
		"PRU-ICSS0_PRU1" : ""
	};
	var pru1 = {
		"PRU-ICSS0_PRU0" : "",
		"PRU-ICSS0_PRU1" : ""
	};

	if (peripheralName == "PRU-ICSS0_MII")
		pru0WrapperUsed = true;
	else if (peripheralName == "PRU-ICSS1_MII")
		pru1WrapperUsed = true;
	else if (peripheralName in pru0)
		pru0GpioUsed = true;
	else if (peripheralName in pru1)
		pru1GpioUsed = true;

	if (( pru0WrapperUsed && pru0GpioUsed ) || ( pru1WrapperUsed && pru1GpioUsed )) {
		var pruErrorMessage = "\n\/*\nWhen the PRU-ICSS_MII pins are selected, the PRU-ICSS internal wrapper multiplexing\n"
		+ "must be configured for PRU-ICSS_MII functionality (or MII mode). In this configuration,\n"
		+ "the PRU peripherals listed below are not available for any other I/O functionality and\n"
		+ "cannot be selected in the PMT. See the device TRM for more details.\n\n"
		+ "\t•\tAny PRU-ICSS0_MIIx pins selected: PRU-ICSS0_PRU0 and PRU-ICSS0_PRU1 cannot be used.\n"
		+ "\t•\tAny PRU-ICSS1_MIIx pins selected: PRU-ICSS1_PRU0 and PRU-ICSS1_PRU1 cannot be used.\n*\/"
		throw new Error( pruErrorMessage );
	}

};

var exportList = {};
for ( var i = 0; i < assignments.length; i++ ) {
	var assignment = assignments[i];
	if ( assignment.devicePin.controlRegisterOffset === "NOT FOUND" ) {
		// do nothing with assignments that have no pad config register
	} else {
		var peripheralName = assignment.peripheral.name;	// get the peripheral name (e.g. SPI2)

		checkPRUICSSInternalWrapper(peripheralName);

		if ( peripheralName in exportList ) {
			exportList[peripheralName].push(assignment);	// add the assignment to that array
		} else {
			exportList[peripheralName] = [];				// make an array with periphal name as the key
			exportList[peripheralName].push(assignment);	// add the assignment to that array
		}
	}
}
;
__p += '\n&k2g_pinctrl {\n';

 for(var peripheralName in exportList) {

	var assignmentList = exportList[peripheralName];

;
__p += '	' +
((__t = (peripheralName.toLowerCase())) == null ? '' : __t) +
'_pins: pinmux_' +
((__t = (peripheralName.toLowerCase())) == null ? '' : __t) +
'_pins {\n		pinctrl-single,pins = <\n';

	for ( var i = 0; i < assignmentList.length; i++ ) {
		var assignment = assignmentList[i];
;
__p += '			K2G_CORE_IOPAD(' +
((__t = (getAddress(assignment))) == null ? '' : __t) +
') (' +
((__t = (getDeviceTreeString(assignment))) == null ? '' : __t) +
') ' +
((__t = ("\t")) == null ? '' : __t) +
'/* ' +
((__t = (assignment.devicePin.designSignalName)) == null ? '' : __t) +
'.' +
((__t = (assignment.peripheralPin.name)) == null ? '' : __t) +
' */\n';
	}
;
__p += '		>;\n	};\n\n';
 }
;
__p += '};\n';
return __p
}; });
defineResource("/66AK2G01/templates/linux/mux-k2g.h.xdt", function(_, system, pmux, scripting, require) { "use strict";return function(args) {
var __t, __p = '', __j = Array.prototype.join;
function print() { __p += __j.call(arguments, '') }

 var $legacy = pmux.getScript("/legacy/adapt.js")(pmux), assignments = $legacy.assignments;
 var date = new Date();
;
__p += '/**\n * Note: This file was auto-generated by TI PinMux on ' +
((__t = (date.toLocaleDateString())) == null ? '' : __t) +
' at ' +
((__t = (date.toLocaleTimeString())) == null ? '' : __t) +
'.\n *\n * \\file mux-k2g.h\n *\n * \\brief This file contains BOOT_CFG register configurations in a pin_cfg\n * structure. The settings are applied with u-boot before the kernel\n * is loaded. For summarization and description of the pad register\n * bits refer to the "Pad Configuration Registers" sub-section of the\n * device Data Manual. This file should only be used as a reference.\n * Some pins and/or peripherals, depending on your use case, may need\n * additional configuration.\n *\n * \\copyright Copyright (CU) ' +
((__t = (date.getFullYear())) == null ? '' : __t) +
' Texas Instruments Incorporated - \n *             http://www.ti.com/\n */\n \n#include <common.h>\n#include <asm/io.h>\n#include <asm/arch/mux-k2g.h>\n#include <asm/arch/hardware.h>\n#include "board.h"\n\n';


var getAddress = function( assignment ) {
	return ( assignment.devicePin.controlRegisterOffset).toString( 16 );
};

// function to return register index based on address offset
var getRegisterIndex = function( offset ) {
	var offsetIndex = (offset - 0x1000)/0x4;
	return offsetIndex;
};

// function read the properties of the UI configuration and return a device tree string
var getDeviceTreeString = function ( assignment ){

	//MUXMODE
	// handle PRUSS / ICSS virtual muxing
	var thisMux = assignment.muxMode;
	if (thisMux > 9) {
		thisMux = 1;
	} else if (thisMux > 5) {
		thisMux = 0;
	}

	var MUXMODE = "MODE(" + thisMux + ")";
	var deviceTreeRegValueString = "PIN_IEN | " + MUXMODE;	// all pins RX always enabled

	//PULL UP/DOWN
	if(assignment.nopull === true){
		deviceTreeRegValueString = "PIN_PDIS | " + deviceTreeRegValueString;
	}else{
		if(assignment.pd === true){
			deviceTreeRegValueString = "PIN_PTD | " + deviceTreeRegValueString;
		}else{
			deviceTreeRegValueString = "PIN_PTU | " + deviceTreeRegValueString;
		}
	}

	//BUFFER CLASS
	if (!_.isEmpty(assignment.configurables)) {

		var bufferClassString = assignment.configurables.buffer_class.name;
		bufferClassString = (bufferClassString.replace("class", "")).toUpperCase();
		
		var buffClassTypes = {"B":"" , "C":"" , "D":"", "E":""};
		if(bufferClassString in buffClassTypes){
			deviceTreeRegValueString = "BUFFER_CLASS_" + bufferClassString + " | " + deviceTreeRegValueString;
		}

	}

	return deviceTreeRegValueString;
};

var pru0GpioUsed = false;
var pru1GpioUsed = false;
var pru0WrapperUsed = false;
var pru1WrapperUsed = false;
function checkPRUICSSInternalWrapper ( peripheralName ) {
	var pru0 = {
		"PRU-ICSS0_PRU0" : "",
		"PRU-ICSS0_PRU1" : ""
	};
	var pru1 = {
		"PRU-ICSS0_PRU0" : "",
		"PRU-ICSS0_PRU1" : ""
	};

	if (peripheralName == "PRU-ICSS0_MII")
		pru0WrapperUsed = true;
	else if (peripheralName == "PRU-ICSS1_MII")
		pru1WrapperUsed = true;
	else if (peripheralName in pru0)
		pru0GpioUsed = true;
	else if (peripheralName in pru1)
		pru1GpioUsed = true;

	if (( pru0WrapperUsed && pru0GpioUsed ) || ( pru1WrapperUsed && pru1GpioUsed )) {
		var pruErrorMessage = "\n\/*\nWhen the PRU-ICSS_MII pins are selected, the PRU-ICSS internal wrapper multiplexing\n"
		+ "must be configured for PRU-ICSS_MII functionality (or MII mode). In this configuration,\n"
		+ "the PRU peripherals listed below are not available for any other I/O functionality and\n"
		+ "cannot be selected in the PMT. See the device TRM for more details.\n\n"
		+ "\t•\tAny PRU-ICSS0_MIIx pins selected: PRU-ICSS0_PRU0 and PRU-ICSS0_PRU1 cannot be used.\n"
		+ "\t•\tAny PRU-ICSS1_MIIx pins selected: PRU-ICSS1_PRU0 and PRU-ICSS1_PRU1 cannot be used.\n*\/"
		throw new Error( pruErrorMessage );
	}

};

var exportList = {};
for ( var i = 0; i < assignments.length; i++ ) {
	var assignment = assignments[i];
	if ( assignment.devicePin.controlRegisterOffset === "NOT FOUND" ) {
		// do nothing with assignments that have no pad config register
	} else {
		var peripheralName = assignment.peripheral.name;	// get the peripheral name (e.g. SPI2)
		
		checkPRUICSSInternalWrapper(peripheralName);
		
		if ( peripheralName in exportList ) {
			exportList[peripheralName].push(assignment);	// add the assignment to that array
		} else {
			exportList[peripheralName] = [];				// make an array with periphal name as the key
			exportList[peripheralName].push(assignment);	// add the assignment to that array
		}
	}
}

;
__p += '\nstruct pin_cfg k2g_pin_cfg[] = {\n';

 for(var peripheralName in exportList) {
	var assignmentList = exportList[peripheralName];

;
__p += '	/* ' +
((__t = (peripheralName.toUpperCase())) == null ? '' : __t) +
' */\n';

	for ( var i = 0; i < assignmentList.length; i++ ) {
		var assignment = assignmentList[i];
;
__p += '	{ ' +
((__t = (getRegisterIndex(assignment.devicePin.controlRegisterOffset))) == null ? '' : __t) +
',' +
((__t = ("\t")) == null ? '' : __t) +
'' +
((__t = (getDeviceTreeString(assignment))) == null ? '' : __t) +
' },' +
((__t = ("\t")) == null ? '' : __t) +
'/* ' +
((__t = (assignment.devicePin.designSignalName)) == null ? '' : __t) +
'.' +
((__t = ((assignment.peripheralPin.name))) == null ? '' : __t) +
' */\n';
	}
;
__p += '\n';
 }
;
__p += '	{ MAX_PIN_N, }\n};\n';
return __p
}; });