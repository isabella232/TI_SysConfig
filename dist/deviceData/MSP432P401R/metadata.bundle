defineResource("/MSP432P401R/templates/Drivers/Board.c.xdt", function(_, system, pmux, scripting, require) { "use strict";return function(args) {
var __t, __p = '', __j = Array.prototype.join;
function print() { __p += __j.call(arguments, '') }

 var $legacy = pmux.getScript("/legacy/adapt.js")(pmux), assignmentErrors = $legacy.assignmentErrors, assignments = $legacy.assignments, peripheralConfigurables = $legacy.peripheralConfigurables, peripheralConfigurations = $legacy.peripheralConfigurations, selectedUseCases = $legacy.selectedUseCases, version = $legacy.version, deviceData = $legacy.deviceData;

    // Change to either "" or "MAP_" depending on if the code is to be in ROM 
    // or not
    var MAP_ = "MAP_";
    
    var date = new Date();

    //PKG number is a number of current package
    var getPKGNumber = function( assignment ) {
        return assignment.devicePin.ball.toString();
    };

    //Return GPIO format: X.Y
    var getGPIONumber = function( assignment ) {
        var temp = assignment.devicePin.designSignalName.toString().split("/")[0]; //PX.Y.GPIO
        return temp.substring(1, temp.length - 5); // remove ".GPIO"
    };

    var getGPIOPort = function( assignment ) {
        var num = getGPIONumber(assignment);
        return num.split(".")[0];
    };

    var getGPIOPin = function( assignment ) {
        var num = getGPIONumber(assignment);
        return num.split(".")[1];
    };

    var getGPIOName = function( assignment ) {
        var name = assignment.peripheralPin.name.split(".")[1];
        return name;
    };

    var getPeripheralPrefix = function( perip ) {
        var res;
        if ((res = perip.match(/^USCI_A[0-9]/gi))) {
            return res[0];
        }
        else if ((res = perip.match(/^USCI_B[0-9]/gi))) {
            return res[0];
        }
        else if ((res = perip.match(/^EUSCI_A[0-9]/gi))) {
            return res[0];
        }
        else if ((res = perip.match(/^EUSCI_B[0-9]/gi))) {
            return res[0];
        }
    };

    var getPeripheralPrefixNoDigit = function( perip ) {
        var res = getPeripheralPrefix(perip);

        return res.replace(/[0-9]/g, '');
    };

;
__p += '//*****************************************************************************\n// Board.c\n//\n// configure the device pins for different signals\n//\n// Copyright (C) 2015 Texas Instruments Incorporated - http://www.ti.com/ \n// \n// \n//  Redistribution and use in source and binary forms, with or without \n//  modification, are permitted provided that the following conditions \n//  are met:\n//\n//    Redistributions of source code must retain the above copyright \n//    notice, this list of conditions and the following disclaimer.\n//\n//    Redistributions in binary form must reproduce the above copyright\n//    notice, this list of conditions and the following disclaimer in the \n//    documentation and/or other materials provided with the   \n//    distribution.\n//\n//    Neither the name of Texas Instruments Incorporated nor the names of\n//    its contributors may be used to endorse or promote products derived\n//    from this software without specific prior written permission.\n//\n//  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \n//  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT \n//  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n//  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT \n//  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, \n//  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT \n//  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n//  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n//  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT \n//  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE \n//  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//\n//*****************************************************************************\n\n// This file was automatically generated on ' +
((__t = (date.toLocaleDateString())) == null ? '' : __t) +
' at ' +
((__t = (date.toLocaleTimeString())) == null ? '' : __t) +
'\n// by TI PinMux version ' +
((__t = (version)) == null ? '' : __t) +
'\n//\n//*****************************************************************************\n';

    var intTable = {'EUSCI_A0_BASE': 'INT_EUSCIA0',
                    'EUSCI_A1_BASE': 'INT_EUSCIA1',
                    'EUSCI_A2_BASE': 'INT_EUSCIA2',
                    'EUSCI_A3_BASE': 'INT_EUSCIA3',
                    'EUSCI_B0_BASE': 'INT_EUSCIB0',
                    'EUSCI_B1_BASE': 'INT_EUSCIB1',
                    'EUSCI_B2_BASE': 'INT_EUSCIB2',
                    'EUSCI_B3_BASE': 'INT_EUSCIB3',
                    'TIMER_A0_BASE': 'INT_TA0_0',
                    'TIMER_A1_BASE': 'INT_TA1_0',
                    'TIMER_A2_BASE': 'INT_TA2_0',
                    'TIMER_A3_BASE': 'INT_TA3_0',
                    'TIMER32_0_BASE': 'INT_T32_INT1',
                    'TIMER32_1_BASE': 'INT_T32_INT2',
                    'WDT_A_BASE': 'INT_WDT_A',};

    var dmaSPIChannel = {'EUSCI_A0_BASE':['DMA_CH1_EUSCIA0RX', 'DMA_CH0_EUSCIA0TX'],
                         'EUSCI_A1_BASE':['DMA_CH3_EUSCIA1RX', 'DMA_CH2_EUSCIA1TX'],
                         'EUSCI_A2_BASE':['DMA_CH5_EUSCIA2RX', 'DMA_CH4_EUSCIA2TX'],
                         'EUSCI_A3_BASE':['DMA_CH7_EUSCIA3RX', 'DMA_CH6_EUSCIA3TX'],
                         'EUSCI_B0_BASE':['DMA_CH1_EUSCIB0RX0', 'DMA_CH0_EUSCIB0TX0'],
                         'EUSCI_B1_BASE':['DMA_CH3_EUSCIB1RX0', 'DMA_CH2_EUSCIB1TX0'],
                         'EUSCI_B2_BASE':['DMA_CH5_EUSCIB2RX0', 'DMA_CH4_EUSCIB2TX0'],
                         'EUSCI_B3_BASE':['DMA_CH7_EUSCIB3RX0', 'DMA_CH6_EUSCIB3TX0'],};
                         
    var availableTimerATable = ["TIMER_A3", "TIMER_A2", "TIMER_A1", "TIMER_A0"];
    var selectedADCBufTimerTrigger = null;

    const adcHWAttrs = [];
    const adcBufHWAttrs = {};
    const adcBufChannels = [];
    const captureHWAttrs = {};
    const displayHWAttrs = {};
    const sdSpiHWAttrs = {};
    const spiHWAttrs = {};
    const uartHWAttrs = {};
    const i2cHWAttrs = {};
    const i2cSlaveHWAttrs = {};
    const gpioConfig = [];
    const powerHWAttrs = {'initialPerfLevel': '2', 'enablePolicy': 'true', 'enablePerf': 'true', 'enableParking': 'true'};
    const pwmHWAttrs = [];
    const timerHWAttrs = {};
    const timer32HWAttrs = {};
    const watchdogHWAttrs = {};

    for( var i = 0; i < assignments.length; i++ ) { //by pin

        var peripPort = getGPIOPort(assignments[i]);
        var peripPin = getGPIOPin(assignments[i]);
        var peripName = assignments[i].peripheral.name;

        if (assignments[i].interfaceName.match(/^GPIO/gi)) {
            // 1 = Input, 0 = Output
            var isIO = assignments[i].configurables['i/o_pu/pd']['name'].indexOf("GPIO_CFG_IN");
            var tempGPIO = 'GPIOMSP432_P' + peripPort +  '_' + peripPin;
            tempGPIO += (" | " + assignments[i].configurables['i/o_pu/pd']['name']);
            
            if(isIO != -1)  //input
            {
                if((assignments[i].configurables['output_value']['name'] != 'none') ||
                    assignments[i].configurables['output_strength']['name'] != 'none')
                {
                    throw new Error("Input needs no output at " + assignments[i].peripheralPin.name);
                }
                tempGPIO += (" | " + assignments[i].configurables['interrupt']['name']);
                gpioConfig.push(tempGPIO);
            }
            else    //output
            {
                if(assignments[i].configurables['interrupt']['name'] != 'GPIO_CFG_IN_INT_NONE')
                {
                    throw new Error("Output needs no interrupt at " + assignments[i].peripheralPin.name);
                }
                if((assignments[i].configurables['output_value']['name'] === 'none') ||
                    assignments[i].configurables['output_strength']['name'] === 'none')
                {
                    throw new Error("Output needs values at " + assignments[i].peripheralPin.name);
                }
                tempGPIO += (" | " + assignments[i].configurables['output_strength']['name']);
                tempGPIO += (" | " + assignments[i].configurables['output_value']['name']);
                gpioConfig.push(tempGPIO);
            }
        }
        else if (assignments[i].interfaceName.match(/^ADC/gi)) {
            if(assignments[i].peripheralPin.interfacePin.name.match(/A[0-9]{1,2}/) == null)
            {
                //skip VREF+, VREF-, VeREF+, or VeREF-
                continue;
            }
            if(selectedUseCases[assignments[i].requirementName].name == "106_usecase_101")  //ADC
            {
                adcHWAttrs.push(
                    {
                        channel: assignments[i].peripheralPin.interfacePin.name, 
                        gpioIdx: i,
                        refVoltage: assignments[i].configurables['adcRefVoltage']['name'],
                        resolution: assignments[i].configurables['resolution']['name'],
                        reqName: assignments[i].requirementName + assignments[i].peripheralPin.interfacePin.name.match(/[^A]{1,2}$/gi)
                    }
                );
            }
            else    //ADCBuf
            {
                var tempRefV;
                if(assignments[i].configurables['adcBufRefVoltage']['name'] === "external") {
                    tempRefV = peripheralConfigurations[peripName]['external'];
                }
                else {
                    tempRefV = assignments[i].configurables['adcBufRefVoltage']['name']
                }
                // TODO: will have to make it a 2D array to fully support multiple ADCBufs
                adcBufChannels.push(
                    {
                        channel: assignments[i].peripheralPin.interfacePin.name,
                        gpioIdx: i,
                        refVoltage: tempRefV,
                        refSource: assignments[i].configurables['refSource']['name']
                    }
                );
            }
        }
        else if (assignments[i].interfaceName.match(/^SYSTEM/gi)) {
            powerHWAttrs['initialPerfLevel'] = peripheralConfigurations[peripName]['initialPerfLevel']['name'];
            powerHWAttrs['enablePolicy'] = peripheralConfigurations[peripName]['enablePolicy']['name'];
            powerHWAttrs['enablePerf'] = peripheralConfigurations[peripName]['enablePerf']['name'];
            powerHWAttrs['enableParking'] = peripheralConfigurations[peripName]['enableParking']['name'];
        }
        else if (assignments[i].interfaceName.match(/^SPI/gi)) {
            if(selectedUseCases[assignments[i].requirementName].name == "101_usecase_102")  //sdSpi
            {
                if (sdSpiHWAttrs[peripName] == null ) {
                    sdSpiHWAttrs[peripName] = {BaseAddr:"", ClockSource:"", 
                                             CLK: {Port:"", Pin:"", Mode:""}, 
                                             SIMO:{Port:"", Pin:"", Mode:""},
                                             SOMI:{Port:"", Pin:"", Mode:""},
                                             STE: {Port:"", Pin:"", Mode:""},
                                             CS:  {Port:"", Pin:"", Mode:""},
                                             ReqName: ""};
                }

                sdSpiHWAttrs[peripName].BaseAddr = getPeripheralPrefix(peripName) + "_BASE";
                sdSpiHWAttrs[peripName].ClockSource = getPeripheralPrefixNoDigit(peripName) + "_SPI_CLOCKSOURCE_" + peripheralConfigurations[peripName]['clock_source']['name'];
                sdSpiHWAttrs[peripName][getGPIOName(assignments[i])].Port = getGPIOPort(assignments[i]);
                sdSpiHWAttrs[peripName][getGPIOName(assignments[i])].Pin = getGPIOPin(assignments[i]);
                sdSpiHWAttrs[peripName][getGPIOName(assignments[i])].Mode = "UC" + getPeripheralPrefix(peripName).split("_")[1] + getGPIOName(assignments[i]);
                sdSpiHWAttrs[peripName].ReqName = assignments[i].requirementName;
            }
            else    //spi
            {
                if (spiHWAttrs[peripName] == null ) {
                    spiHWAttrs[peripName] = {BaseAddr:"", BitOrder:"", ClockSource:"", 
                                             CLK: {Port:"", Pin:"", Mode:""}, 
                                             SIMO:{Port:"", Pin:"", Mode:""},
                                             SOMI:{Port:"", Pin:"", Mode:""},
                                             STE: {Port:"", Pin:"", Mode:""},
                                             PinMode:"", ReqName:""};
                }

                spiHWAttrs[peripName].BaseAddr = getPeripheralPrefix(peripName) + "_BASE";
                spiHWAttrs[peripName].BitOrder = getPeripheralPrefixNoDigit(peripName) + "_SPI_" + peripheralConfigurations[peripName]['bit_order']['name'];
                spiHWAttrs[peripName].ClockSource = getPeripheralPrefixNoDigit(peripName) + "_SPI_CLOCKSOURCE_" + peripheralConfigurations[peripName]['clock_source']['name'];
                spiHWAttrs[peripName].PinMode = peripheralConfigurations[peripName]['pin_mode']['name'];
                spiHWAttrs[peripName][getGPIOName(assignments[i])].Port = getGPIOPort(assignments[i]);
                spiHWAttrs[peripName][getGPIOName(assignments[i])].Pin = getGPIOPin(assignments[i]);
                spiHWAttrs[peripName][getGPIOName(assignments[i])].Mode = "UC" + getPeripheralPrefix(peripName).split("_")[1] + getGPIOName(assignments[i]);
                spiHWAttrs[peripName].ReqName = assignments[i].requirementName;
            }
        }
        else if (assignments[i].interfaceName.match(/^UART/gi)) {
            if (uartHWAttrs[peripName] == null ) {
                uartHWAttrs[peripName] = {BaseAddr:"", BitOrder:"", ClockSource:"",
                                          RXD: {Port:"", Pin:"", Mode:""}, 
                                          TXD: {Port:"", Pin:"", Mode:""},
                                          ReqName:""};
            }

            uartHWAttrs[peripName].BaseAddr = getPeripheralPrefix(peripName) + "_BASE";
            uartHWAttrs[peripName].BitOrder = getPeripheralPrefixNoDigit(peripName) + "_UART_" + peripheralConfigurations[peripName]['bit_order']['name'];
            uartHWAttrs[peripName].ClockSource = getPeripheralPrefixNoDigit(peripName) + "_UART_CLOCKSOURCE_" + peripheralConfigurations[peripName]['clock_source']['name'];
            uartHWAttrs[peripName][getGPIOName(assignments[i])].Port = getGPIOPort(assignments[i]);
            uartHWAttrs[peripName][getGPIOName(assignments[i])].Pin = getGPIOPin(assignments[i]);
            uartHWAttrs[peripName][getGPIOName(assignments[i])].Mode = "UC" + getPeripheralPrefix(peripName).split("_")[1] + getGPIOName(assignments[i]);
            uartHWAttrs[peripName].ReqName = assignments[i].requirementName;
        }
        else if (assignments[i].interfaceName.match(/^DISPLAY/gi)) {
            if (displayHWAttrs[peripName] == null) {
                displayHWAttrs[peripName] = {BaseAddr:"", BitOrder:"", ClockSource:"",
                                          RXD: {Port:"", Pin:"", Mode:""}, 
                                          TXD: {Port:"", Pin:"", Mode:""},
                                          ReqName:"", BaudRate:""}
            }
            displayHWAttrs[peripName].ReqName = assignments[i].requirementName;
            displayHWAttrs[peripName].BaudRate = peripheralConfigurations[peripName]['baud_rate']['name'];
            displayHWAttrs[peripName].BaseAddr = getPeripheralPrefix(peripName) + "_BASE";
            displayHWAttrs[peripName][getGPIOName(assignments[i])].Port = getGPIOPort(assignments[i]);
            displayHWAttrs[peripName][getGPIOName(assignments[i])].Pin = getGPIOPin(assignments[i]);
            displayHWAttrs[peripName][getGPIOName(assignments[i])].Mode = "UC" + getPeripheralPrefix(peripName).split("_")[1] + getGPIOName(assignments[i]);
            displayHWAttrs[peripName].BitOrder = getPeripheralPrefixNoDigit(peripName) + "_UART_" + peripheralConfigurations[peripName]['bit_order']['name'];
            displayHWAttrs[peripName].ClockSource = getPeripheralPrefixNoDigit(peripName) + "_UART_CLOCKSOURCE_" + peripheralConfigurations[peripName]['clock_source']['name'];
            if (Object.keys(displayHWAttrs).length > 1) {
                throw new Error("Only one Display module allowed!");
            }
        }
        else if (assignments[i].interfaceName.match(/^I2C/gi)) {
            if (selectedUseCases[assignments[i].requirementName].name == "103_usecase_101")  //i2cMaster
            {
                if (i2cHWAttrs[peripName] == null ) {
                i2cHWAttrs[peripName] = {BaseAddr:"", ClockSource:"",
                                          SCL: {Port:"", Pin:"", Mode:""}, 
                                          SDA: {Port:"", Pin:"", Mode:""},
                                          ReqName:""};
                }

                i2cHWAttrs[peripName].BaseAddr = getPeripheralPrefix(peripName) + "_BASE";
                i2cHWAttrs[peripName].ClockSource = getPeripheralPrefixNoDigit(peripName) + "_I2C_CLOCKSOURCE_" + peripheralConfigurations[peripName]['clock_source']['name'];
                i2cHWAttrs[peripName][getGPIOName(assignments[i])].Port = getGPIOPort(assignments[i]);
                i2cHWAttrs[peripName][getGPIOName(assignments[i])].Pin = getGPIOPin(assignments[i]);
                i2cHWAttrs[peripName][getGPIOName(assignments[i])].Mode = "UC" + getPeripheralPrefix(peripName).split("_")[1] + getGPIOName(assignments[i]);
                i2cHWAttrs[peripName].ReqName = assignments[i].requirementName
            }
            else {  //i2cSlave
                if (i2cSlaveHWAttrs[peripName] == null ) {
                    i2cSlaveHWAttrs[peripName] = {BaseAddr:"", SlaveAddress:"",
                                              SCL: {Port:"", Pin:"", Mode:""}, 
                                              SDA: {Port:"", Pin:"", Mode:""},
                                              ReqName:""};
                }

                i2cSlaveHWAttrs[peripName].BaseAddr = getPeripheralPrefix(peripName) + "_BASE";
                i2cSlaveHWAttrs[peripName].SlaveAddress = peripheralConfigurations[peripName]['slave_address'];
                i2cSlaveHWAttrs[peripName][getGPIOName(assignments[i])].Port = getGPIOPort(assignments[i]);
                i2cSlaveHWAttrs[peripName][getGPIOName(assignments[i])].Pin = getGPIOPin(assignments[i]);
                i2cSlaveHWAttrs[peripName][getGPIOName(assignments[i])].Mode = "UC" + getPeripheralPrefix(peripName).split("_")[1] + getGPIOName(assignments[i]);
                i2cSlaveHWAttrs[peripName].ReqName = assignments[i].requirementName;
            }
        }
        else if (assignments[i].interfaceName.match(/^TIMER_A/gi)) {
            if (selectedUseCases[assignments[i].requirementName].name == "104_usecase_102")    //PWM
            {
                pwmHWAttrs.push(
                    {
                        ClockSource: peripName.replace(/[0-9]/g,'').toUpperCase() + '_CLOCKSOURCE_' + peripheralConfigurations[peripName]['clock_source']['name'],
                        CCR: "T" + peripName.split("_")[1] + "CCR" + assignments[i].peripheralPin.name.match(/[0-4]$/g) + peripName.split("_")[1].replace(/[0-9]/g,''),
                        GPIOPort: getGPIOPort(assignments[i]),
                        GPIOPin: getGPIOPin(assignments[i]),
                        ReqName: assignments[i].requirementName + '_' + assignments[i].peripheralPin.name.split('.')[1]
                    }
                );
            }
            else if (selectedUseCases[assignments[i].requirementName].name == "104_usecase_103")    //Capture
            {
                if (captureHWAttrs[peripName] != null) {
                    throw new Error("Capture only allows one active CCI pin per module!");
                }
                if (captureHWAttrs[peripName] == null ) {
                    captureHWAttrs[peripName] = {BaseAddr:"", ClockSource:"", ClockDivider:"", CapturePort:"", ReqName:""};
                }
                
                captureHWAttrs[peripName].BaseAddr = peripName.toUpperCase() + "_BASE";
                captureHWAttrs[peripName].ClockSource = peripName.replace(/[0-9]/g,'').toUpperCase() + '_CLOCKSOURCE_' + peripheralConfigurations[peripName]['clock_source']['name'];
                captureHWAttrs[peripName].ClockDivider = peripheralConfigurations[peripName]['clock_divider']['name'];
                captureHWAttrs[peripName].CapturePort = 'CaptureMSP432_P' + getGPIOPort(assignments[i]) + "_" + getGPIOPin(assignments[i]) + "_T" + peripName.split("_")[1];
                captureHWAttrs[peripName].ReqName = assignments[i].requirementName;
            }
        }
    }
    
    for ( var i = 0; i < peripheralConfigurables.length; i++)   //by driver
    {
        
        peripName = peripheralConfigurables[i].peripheral;
        
        if (peripheralConfigurables[i].interfaceName.match(/^TIMER_A/gi)) {
            if (timerHWAttrs[peripName] == null ) {
                timerHWAttrs[peripName] = {BaseAddr:"", ClockSource:"", ReqName:""};
            }
            
            timerHWAttrs[peripName].BaseAddr = peripName.toUpperCase() + "_BASE";
            timerHWAttrs[peripName].ClockSource = peripName.replace(/[0-9]/g,'').toUpperCase() + '_CLOCKSOURCE_' + peripheralConfigurations[peripName]['clock_source']['name'];
            timerHWAttrs[peripName].ReqName = peripheralConfigurables[i].requirementName;
            if (selectedUseCases[peripheralConfigurables[i].requirementName].name != "104_usecase_101") //not Timer
            {
                timerHWAttrs[peripName].ReqName += "_TIMER";
            }
            availableTimerATable = _.without(availableTimerATable, peripName.toUpperCase());
        }
        else if (peripheralConfigurables[i].interfaceName.match(/^TIMER32/gi)) {
            if (timer32HWAttrs[peripName] == null) {
                timer32HWAttrs[peripName] = {BaseAddr:"", ClockSource:"", ReqName:""};
            }
            
            timer32HWAttrs[peripName].BaseAddr = peripName.toUpperCase() + "_BASE";
            timer32HWAttrs[peripName].ClockSource = "TIMER_A_CLOCKSOURCE_" + peripheralConfigurables[i].configurables['clock_source']['name'];
            timer32HWAttrs[peripName].ReqName = peripheralConfigurables[i].requirementName;
        }
        else if (peripheralConfigurables[i].interfaceName.match(/^WATCHDOG/gi)) {
            if (watchdogHWAttrs[peripName] == null) {
                watchdogHWAttrs[peripName] = {BaseAddr:"", ClockSource:"", ClockDivider:"", ReqName:""};
            }
            watchdogHWAttrs[peripName].BaseAddr = 'WDT_A_BASE';
            watchdogHWAttrs[peripName].ClockSource = 'WDT_A_CLOCKSOURCE_' + peripheralConfigurables[i].configurables['wdtClockSource']['name'];
            watchdogHWAttrs[peripName].ClockDivider = 'WDT_A_CLOCKDIVIDER_' + peripheralConfigurables[i].configurables['wdtClockDivider']['name'];
            watchdogHWAttrs[peripName].ReqName = peripheralConfigurables[i].requirementName;
        }
        else if (peripheralConfigurables[i].interfaceName.match(/^ADC/gi)) {
            if(selectedUseCases[peripheralConfigurables[i].requirementName].name == "106_usecase_102")  //ADCBuf
            {
                if (adcBufHWAttrs[peripName] == null) {
                    adcBufHWAttrs[peripName] = {ReqName:""};
                }
                adcBufHWAttrs[peripName].ReqName = peripheralConfigurables[i].requirementName;
            }
        }
    }
    for ( var i = 0; i < peripheralConfigurables.length; i++)
    {
        if (peripheralConfigurables[i].interfaceName.match(/^ADC/gi)) {
            if(selectedUseCases[peripheralConfigurables[i].requirementName].name == "106_usecase_102")  //ADCBuf
            {
                if(availableTimerATable.length == 0)
                {
                    throw new Error("No available TIMER_A left for ADCBuf");
                }
                if(!(_.includes(availableTimerATable, peripheralConfigurables[i].configurables['timer_trigger']['name'].split("_")[1].toUpperCase().replace("TIMER", "TIMER_"))))
                {
                    throw new Error("ADCBuf's selected timer trigger is already in use!");
                }
                selectedADCBufTimerTrigger = peripheralConfigurables[i].configurables['timer_trigger']['name'];
                if (timerHWAttrs[peripName] == null ) {
                    timerHWAttrs[peripName] = {BaseAddr:"", ClockSource:"", ReqName:""};
                }
                
                timerHWAttrs[peripName].BaseAddr =  peripheralConfigurables[i].configurables['timer_trigger']['name'].split("_")[1].toUpperCase().replace("TIMER", "TIMER_") + "_BASE";
                timerHWAttrs[peripName].ClockSource =  "TIMER_A_CLOCKSOURCE_SMCLK";
                timerHWAttrs[peripName].ReqName = peripheralConfigurables[i].requirementName + "_TIMER";
                availableTimerATable = _.without(availableTimerATable, peripheralConfigurables[i].configurables['timer_trigger']['name'].split("_")[1].toUpperCase().replace("TIMER", "TIMER_"));
            }
        }
    }
;
__p += '\n#include <stdbool.h>\n\n#include <ti/drivers/Power.h>\n#include <ti/drivers/power/PowerMSP432.h>\n\n#include <ti/devices/msp432p4xx/inc/msp.h>\n#include <ti/devices/msp432p4xx/driverlib/rom.h>\n#include <ti/devices/msp432p4xx/driverlib/rom_map.h>\n#include <ti/devices/msp432p4xx/driverlib/adc14.h>\n#include <ti/devices/msp432p4xx/driverlib/dma.h>\n#include <ti/devices/msp432p4xx/driverlib/gpio.h>\n#include <ti/devices/msp432p4xx/driverlib/i2c.h>\n#include <ti/devices/msp432p4xx/driverlib/interrupt.h>\n#include <ti/devices/msp432p4xx/driverlib/pmap.h>\n#include <ti/devices/msp432p4xx/driverlib/ref_a.h>\n#include <ti/devices/msp432p4xx/driverlib/spi.h>\n#include <ti/devices/msp432p4xx/driverlib/timer_a.h>\n#include <ti/devices/msp432p4xx/driverlib/timer32.h>\n#include <ti/devices/msp432p4xx/driverlib/uart.h>\n#include <ti/devices/msp432p4xx/driverlib/wdt_a.h>\n\n#include "Board.h"\n\n';
  if(adcHWAttrs.length > 0) {
;
__p += '/*\n *  =============================== ADC ===============================\n */\n#include <ti/drivers/ADC.h>\n#include <ti/drivers/adc/ADCMSP432.h>\n\n/* ADC objects */\nADCMSP432_Object adcMSP432Objects[Board_ADCCOUNT];\n\n/* ADC configuration structure */\nconst ADCMSP432_HWAttrsV1 adcMSP432HWAttrs[Board_ADCCOUNT] = {\n';
  for(var i=0; i<adcHWAttrs.length; i++) {
;
__p += '    {\n        .adcPin = ADCMSP432_P' +
((__t = (getGPIOPort(assignments[adcHWAttrs[i].gpioIdx]))) == null ? '' : __t) +
'_' +
((__t = (getGPIOPin(assignments[adcHWAttrs[i].gpioIdx]))) == null ? '' : __t) +
'_' +
((__t = (adcHWAttrs[i].channel)) == null ? '' : __t) +
',\n        .refVoltage = ' +
((__t = (adcHWAttrs[i].refVoltage)) == null ? '' : __t) +
',\n        .resolution = ' +
((__t = (adcHWAttrs[i].resolution)) == null ? '' : __t) +
',\n    },\n';
   }
;
__p += '};\n\nconst ADC_Config ADC_config[Board_ADCCOUNT] = {\n';
  for(var i=0; i<adcHWAttrs.length; i++) {
;
__p += '    {\n        .fxnTablePtr = &ADCMSP432_fxnTable,\n        .object = &adcMSP432Objects[' +
((__t = (adcHWAttrs[i].reqName)) == null ? '' : __t) +
'],\n        .hwAttrs = &adcMSP432HWAttrs[' +
((__t = (adcHWAttrs[i].reqName)) == null ? '' : __t) +
']\n    },\n';
   }
;
__p += '};\n\nconst uint_least8_t ADC_count = Board_ADCCOUNT;\n';
  }
  if((adcBufHWAttrs.length > 0) || (selectedADCBufTimerTrigger != null)) {
;
__p += '/*\n *  =============================== ADCBuf ===============================\n */\n#include <ti/drivers/ADCBuf.h>\n#include <ti/drivers/adcbuf/ADCBufMSP432.h>\n\n/* ADCBuf objects */\nADCBufMSP432_Object adcbufMSP432Objects[Board_ADCBUFCOUNT];\n\n/* ADCBuf configuration structure */\n';
  for(var j=0; j<1; j++) {
;
__p += 'ADCBufMSP432_Channels adcBuf' +
((__t = (j)) == null ? '' : __t) +
'MSP432Channels[Board_ADCBUF' +
((__t = (j)) == null ? '' : __t) +
'CHANNELCOUNT] = {\n';
  for(var i=0; i<adcBufChannels.length; i++) {
;
__p += '    {\n        .adcPin = ADCBufMSP432_P' +
((__t = (getGPIOPort(assignments[adcBufChannels[i].gpioIdx]))) == null ? '' : __t) +
'_' +
((__t = (getGPIOPin(assignments[adcBufChannels[i].gpioIdx]))) == null ? '' : __t) +
'_' +
((__t = (adcBufChannels[i].channel)) == null ? '' : __t) +
',\n        .refSource = ADCBufMSP432_' +
((__t = (adcBufChannels[i].refSource)) == null ? '' : __t) +
',\n        .refVoltage = ' +
((__t = (adcBufChannels[i].refVoltage)) == null ? '' : __t) +
',\n    },\n';
   }
;
__p += '};\n';
   }
;
__p += '\n/* ADC configuration structure */\n';
  for(var j=0; j<1; j++) {
;
__p += 'const ADCBufMSP432_HWAttrs adcbufMSP432HWAttrs[Board_ADCBUFCOUNT] = {\n    {\n        .intPriority =  ~0,\n        .channelSetting = adcBuf' +
((__t = (j)) == null ? '' : __t) +
'MSP432Channels,\n        .adcTimerTriggerSource = ' +
((__t = (selectedADCBufTimerTrigger)) == null ? '' : __t) +
'\n    }\n};\n';
   }
;
__p += '\nconst ADCBuf_Config ADCBuf_config[Board_ADCBUFCOUNT] = {\n';
  for(var key in adcBufHWAttrs) {
;
__p += '    {\n        .fxnTablePtr = &ADCBufMSP432_fxnTable,\n        .object = &adcbufMSP432Objects[' +
((__t = (adcBufHWAttrs[key].ReqName)) == null ? '' : __t) +
'],\n        .hwAttrs = &adcbufMSP432HWAttrs[' +
((__t = (adcBufHWAttrs[key].ReqName)) == null ? '' : __t) +
']\n    },\n';
   }
;
__p += '};\n\nconst uint_least8_t ADCBuf_count = Board_ADCBUFCOUNT;\n';
  }
  if(Object.keys(captureHWAttrs).length > 0) {
;
__p += '/*\n *  ============================= Capture =============================\n */\n#include <ti/drivers/Capture.h>\n#include <ti/drivers/capture/CaptureMSP432.h>\n\nCaptureMSP432_Object captureMSP432Objects[Board_CAPTURECOUNT];\n\nconst CaptureMSP432_HWAttrs captureMSP432HWAttrs[Board_CAPTURECOUNT] = {\n';
  for( var key in captureHWAttrs) {
;
__p += '    {        \n        .timerBaseAddress = ' +
((__t = (captureHWAttrs[key].BaseAddr)) == null ? '' : __t) +
',\n        .clockSource = ' +
((__t = (captureHWAttrs[key].ClockSource)) == null ? '' : __t) +
',\n        .clockDivider = ' +
((__t = (captureHWAttrs[key].ClockDivider)) == null ? '' : __t) +
',\n        .capturePort = ' +
((__t = (captureHWAttrs[key].CapturePort)) == null ? '' : __t) +
',\n        .intPriority = ~0\n    },\n';
   }
;
__p += '};\n\nconst Capture_Config Capture_config[Board_CAPTURECOUNT] = {\n';
  for(var key in captureHWAttrs) {
;
__p += '    {\n        .fxnTablePtr = &CaptureMSP432_captureFxnTable,\n        .object = &captureMSP432Objects[' +
((__t = (captureHWAttrs[key].ReqName)) == null ? '' : __t) +
'],\n        .hwAttrs = &captureMSP432HWAttrs[' +
((__t = (captureHWAttrs[key].ReqName)) == null ? '' : __t) +
']\n    },\n';
   }
;
__p += '};\n\nconst uint_least8_t Capture_count = Board_CAPTURECOUNT;\n';
  }
;
__p += '\n/*\n *  =============================== DMA ===============================\n */\n#include <ti/drivers/dma/UDMAMSP432.h>\n\n#if defined(__TI_COMPILER_VERSION__)\n#pragma DATA_ALIGN(dmaControlTable, 256)\n#elif defined(__IAR_SYSTEMS_ICC__)\n#pragma data_alignment=256\n#elif defined(__GNUC__)\n__attribute__ ((aligned (256)))\n#endif\nstatic DMA_ControlTable dmaControlTable[8];\n\n/*\n *  ======== dmaErrorHwi ========\n *  This is the handler for the uDMA error interrupt.\n */\nstatic void dmaErrorHwi(uintptr_t arg)\n{\n    int status = MAP_DMA_getErrorStatus();\n    MAP_DMA_clearErrorStatus();\n\n    /* Suppress unused variable warning */\n    (void)status;\n\n    while (1);\n}\n\nUDMAMSP432_Object udmaMSP432Object;\n\nconst UDMAMSP432_HWAttrs udmaMSP432HWAttrs = {\n    .controlBaseAddr = (void *)dmaControlTable,\n    .dmaErrorFxn = (UDMAMSP432_ErrorFxn)dmaErrorHwi,\n    .intNum = INT_DMA_ERR,\n    .intPriority = (~0)\n};\n\nconst UDMAMSP432_Config UDMAMSP432_config = {\n    .object = &udmaMSP432Object,\n    .hwAttrs = &udmaMSP432HWAttrs\n};\n\n';
  if(Object.keys(displayHWAttrs).length > 0) {
;
__p += '/*\n *  ============================= Display =============================\n */\n#include <ti/display/Display.h>\n#include <ti/display/DisplayUart.h>\n#define MAXPRINTLEN 1024\n\nDisplayUart_Object displayUartObject;\n\nstatic char displayBuf[MAXPRINTLEN];\n\nconst DisplayUart_HWAttrs displayUartHWAttrs = {\n';
  for(var key in displayHWAttrs) {
;
__p += '    .uartIdx = ' +
((__t = (displayHWAttrs[key].ReqName)) == null ? '' : __t) +
',\n    .baudRate = ' +
((__t = (displayHWAttrs[key].BaudRate)) == null ? '' : __t) +
',\n    .mutexTimeout = (unsigned int)(-1),\n    .strBuf = displayBuf,\n    .strBufLen = MAXPRINTLEN\n';
  }
;
__p += '};\n\nconst Display_Config Display_config[] = {\n    {\n#  if defined(BOARD_DISPLAY_UART_USE_ANSI)\n        .fxnTablePtr = &DisplayUartAnsi_fxnTable,\n#  else /* Default to minimal UART with no cursor placement */\n        .fxnTablePtr = &DisplayUartMin_fxnTable,\n#  endif\n        .object = &displayUartObject,\n        .hwAttrs = &displayUartHWAttrs\n    },\n};\n\nconst uint_least8_t Display_count = sizeof(Display_config) / sizeof(Display_Config);\n';
  }
;
__p += '\n/*\n *  ======== MSP_EXP432P401R_initGeneral ========\n */\nvoid MSP_EXP432P401R_initGeneral(void)\n{\n    Power_init();\n}\n\n';
  if(gpioConfig.length > 0) {
;
__p += '/*\n *  =============================== GPIO ===============================\n */\n#include <ti/drivers/GPIO.h>\n#include <ti/drivers/gpio/GPIOMSP432.h>\n\n/*\n * Array of Pin configurations\n * NOTE: The order of the pin configurations must coincide with what was\n *       defined in MSP_EXP432P401R.h\n * NOTE: Pins not used for interrupts should be placed at the end of the\n *       array.  Callback entries can be omitted from callbacks array to\n *       reduce memory usage.\n */\nGPIO_PinConfig gpioPinConfigs[] = {\n';
  for(var i=0; i<gpioConfig.length; i++) {
;
__p += '    ' +
((__t = (gpioConfig[i])) == null ? '' : __t) +
',\n';
   }
;
__p += '};\n\n/*\n * Array of callback function pointers\n * NOTE: The order of the pin configurations must coincide with what was\n *       defined in MSP_EXP432P401R.h\n * NOTE: Pins not used for interrupts can be omitted from callbacks array to\n *       reduce memory usage (if placed at end of gpioPinConfigs array).\n */\nGPIO_CallbackFxn gpioCallbackFunctions[] = {\n    NULL,\n    NULL\n};\n\nconst GPIOMSP432_Config GPIOMSP432_config = {\n    .pinConfigs = (GPIO_PinConfig *)gpioPinConfigs,\n    .callbacks = (GPIO_CallbackFxn *)gpioCallbackFunctions,\n    .numberOfPinConfigs = sizeof(gpioPinConfigs)/sizeof(GPIO_PinConfig),\n    .numberOfCallbacks = sizeof(gpioCallbackFunctions)/sizeof(GPIO_CallbackFxn),\n    .intPriority = (~0)\n};\n';
  }
  if(Object.keys(i2cHWAttrs).length > 0) {
;
__p += '/*\n *  =============================== I2C ===============================\n */\n#include <ti/drivers/I2C.h>\n#include <ti/drivers/i2c/I2CMSP432.h>\n\nI2CMSP432_Object i2cMSP432Objects[Board_I2CCOUNT];\n\nconst I2CMSP432_HWAttrsV1 i2cMSP432HWAttrs[Board_I2CCOUNT] = {\n';
  var i = 0;
  for( var key in i2cHWAttrs) {
;
__p += '    {\n        .baseAddr = ' +
((__t = (i2cHWAttrs[key].BaseAddr)) == null ? '' : __t) +
',\n        .intNum = ' +
((__t = (intTable[i2cHWAttrs[key].BaseAddr])) == null ? '' : __t) +
',\n        .intPriority = (~0),\n        .clockSource = ' +
((__t = (i2cHWAttrs[key].ClockSource)) == null ? '' : __t) +
',\n        .dataPin = I2CMSP432_P' +
((__t = (i2cHWAttrs[key]["SDA"]["Port"])) == null ? '' : __t) +
'_' +
((__t = (i2cHWAttrs[key]["SDA"]["Pin"])) == null ? '' : __t) +
'_' +
((__t = (i2cHWAttrs[key]["SDA"]["Mode"])) == null ? '' : __t) +
',\n        .clkPin = I2CMSP432_P' +
((__t = (i2cHWAttrs[key]["SCL"]["Port"])) == null ? '' : __t) +
'_' +
((__t = (i2cHWAttrs[key]["SCL"]["Pin"])) == null ? '' : __t) +
'_' +
((__t = (i2cHWAttrs[key]["SCL"]["Mode"])) == null ? '' : __t) +
',\n    },\n';
   }
;
__p += '};\n\nconst I2C_Config I2C_config[Board_I2CCOUNT] = {\n';
  for(var key in i2cHWAttrs) {
;
__p += '    {\n        .fxnTablePtr = &I2CMSP432_fxnTable,\n        .object = &i2cMSP432Objects[' +
((__t = (i2cHWAttrs[key].ReqName)) == null ? '' : __t) +
'],\n        .hwAttrs = &i2cMSP432HWAttrs[' +
((__t = (i2cHWAttrs[key].ReqName)) == null ? '' : __t) +
']\n    },\n';
   }
;
__p += '};\n\nconst uint_least8_t I2C_count = Board_I2CCOUNT;\n';
  }
  if(Object.keys(i2cSlaveHWAttrs).length > 0) {
;
__p += '/*\n *  =============================== I2CSlave ===============================\n */\n#include <ti/drivers/I2CSlave.h>\n#include <ti/drivers/i2cslave/I2CSlaveMSP432.h>\n\nI2CSlaveMSP432_Object i2cSlaveMSP432Objects[Board_I2CSLAVECOUNT];\n\nconst I2CSlaveMSP432_HWAttrs i2cSlaveMSP432HWAttrs[Board_I2CSLAVECOUNT] = {\n';
  var i = 0;
  for( var key in i2cSlaveHWAttrs) {
;
__p += '    {\n        .baseAddr = ' +
((__t = (i2cSlaveHWAttrs[key].BaseAddr)) == null ? '' : __t) +
',\n        .intNum = ' +
((__t = (intTable[i2cSlaveHWAttrs[key].BaseAddr])) == null ? '' : __t) +
',\n        .intPriority = ~0,\n        .slaveAddress = ' +
((__t = (i2cSlaveHWAttrs[key].SlaveAddress)) == null ? '' : __t) +
',\n        .dataPin = I2CSLAVEMSP432_P' +
((__t = (i2cSlaveHWAttrs[key]["SDA"]["Port"])) == null ? '' : __t) +
'_' +
((__t = (i2cSlaveHWAttrs[key]["SDA"]["Pin"])) == null ? '' : __t) +
'_' +
((__t = (i2cSlaveHWAttrs[key]["SDA"]["Mode"])) == null ? '' : __t) +
',\n        .clkPin = I2CSLAVEMSP432_P' +
((__t = (i2cSlaveHWAttrs[key]["SCL"]["Port"])) == null ? '' : __t) +
'_' +
((__t = (i2cSlaveHWAttrs[key]["SCL"]["Pin"])) == null ? '' : __t) +
'_' +
((__t = (i2cSlaveHWAttrs[key]["SCL"]["Mode"])) == null ? '' : __t) +
',\n    },\n';
   }
;
__p += '};\n\nconst I2CSlave_Config I2CSlave_config[Board_I2CSLAVECOUNT] = {\n';
  for(var key in i2cSlaveHWAttrs) {
;
__p += '    {\n        .fxnTablePtr = &I2CSlaveMSP432_fxnTable,\n        .object = &i2cSlaveMSP432Objects[' +
((__t = (i2cSlaveHWAttrs[key].ReqName)) == null ? '' : __t) +
'],\n        .hwAttrs = &i2cSlaveMSP432HWAttrs[' +
((__t = (i2cSlaveHWAttrs[key].ReqName)) == null ? '' : __t) +
']\n    },\n';
   }
;
__p += '};\n\nconst uint_least8_t I2CSlave_count = Board_I2CSLAVECOUNT;\n';
  }
;
__p += '/*\n *  =============================== Power ===============================\n */\nconst PowerMSP432_ConfigV1 PowerMSP432_config = {\n    .policyInitFxn = &PowerMSP432_initPolicy,\n    .policyFxn = &PowerMSP432_sleepPolicy,\n    .initialPerfLevel = ' +
((__t = (powerHWAttrs['initialPerfLevel'])) == null ? '' : __t) +
',\n    .enablePolicy = ' +
((__t = (powerHWAttrs['enablePolicy'])) == null ? '' : __t) +
',\n    .enablePerf = ' +
((__t = (powerHWAttrs['enablePerf'])) == null ? '' : __t) +
',\n    .enableParking = ' +
((__t = (powerHWAttrs['enableParking'])) == null ? '' : __t) +
'\n};\n';
  if(pwmHWAttrs.length > 0) {
;
__p += '/*\n *  =============================== PWM ===============================\n */\n#include <ti/drivers/PWM.h>\n#include <ti/drivers/pwm/PWMTimerMSP432.h>\n\nPWMTimerMSP432_Object pwmTimerMSP432Objects[Board_PWMCOUNT];\n\nconst PWMTimerMSP432_HWAttrsV2 pwmTimerMSP432HWAttrs[Board_PWMCOUNT] = {\n';
  for(var i=0; i<pwmHWAttrs.length; i++) {
;
__p += '    {        \n        .clockSource = ' +
((__t = (pwmHWAttrs[i].ClockSource)) == null ? '' : __t) +
',\n        .pwmPin = PWMTimerMSP432_P' +
((__t = (pwmHWAttrs[i].GPIOPort)) == null ? '' : __t) +
'_' +
((__t = (pwmHWAttrs[i].GPIOPin)) == null ? '' : __t) +
'_' +
((__t = (pwmHWAttrs[i].CCR)) == null ? '' : __t) +
',\n    },\n';
   }
;
__p += '};\n\nconst PWM_Config PWM_config[Board_PWMCOUNT] = {\n';
  for(var i=0; i<pwmHWAttrs.length; i++) {
;
__p += '    {\n        .fxnTablePtr = &PWMTimerMSP432_fxnTable,\n        .object = &pwmTimerMSP432Objects[' +
((__t = (pwmHWAttrs[i].ReqName)) == null ? '' : __t) +
'],\n        .hwAttrs = &pwmTimerMSP432HWAttrs[' +
((__t = (pwmHWAttrs[i].ReqName)) == null ? '' : __t) +
']\n    },\n';
   }
;
__p += '};\n\nconst uint_least8_t PWM_count = Board_PWMCOUNT;\n';
  }
  if(Object.keys(sdSpiHWAttrs).length > 0) {
;
__p += '\n/*\n *  =============================== SDSPI ===============================\n */\n#include <ti/drivers/SDSPI.h>\n#include <ti/drivers/sdspi/SDSPIMSP432.h>\n\n/* SDSPI objects */\nSDSPIMSP432_Object sdspiMSP432Objects[Board_SDSPICOUNT];\n\n/* SDSPI configuration structure */\nconst SDSPIMSP432_HWAttrsV1 sdspiMSP432HWAttrs[Board_SDSPICOUNT] = {\n';
  var i = 0;
  for( var key in sdSpiHWAttrs) {
;
__p += '    {\n        .baseAddr = ' +
((__t = (sdSpiHWAttrs[key].BaseAddr)) == null ? '' : __t) +
',\n        .clockSource = ' +
((__t = (sdSpiHWAttrs[key].ClockSource)) == null ? '' : __t) +
',\n        \n        /* CLK, MOSI & MISO ports & pins */\n        .sckPin = SDSPIMSP432_P' +
((__t = (sdSpiHWAttrs[key].CLK.Port)) == null ? '' : __t) +
'_' +
((__t = (sdSpiHWAttrs[key].CLK.Pin)) == null ? '' : __t) +
'_' +
((__t = (sdSpiHWAttrs[key].CLK.Mode)) == null ? '' : __t) +
',\n        .somiPin = SDSPIMSP432_P' +
((__t = (sdSpiHWAttrs[key].SOMI.Port)) == null ? '' : __t) +
'_' +
((__t = (sdSpiHWAttrs[key].SOMI.Pin)) == null ? '' : __t) +
'_' +
((__t = (sdSpiHWAttrs[key].SOMI.Mode)) == null ? '' : __t) +
',\n        .simoPin = SDSPIMSP432_P' +
((__t = (sdSpiHWAttrs[key].SIMO.Port)) == null ? '' : __t) +
'_' +
((__t = (sdSpiHWAttrs[key].SIMO.Pin)) == null ? '' : __t) +
'_' +
((__t = (sdSpiHWAttrs[key].SIMO.Mode)) == null ? '' : __t) +
',\n        \n        /* Chip select port & pin */\n        .csPin = SDSPIMSP432_P' +
((__t = (sdSpiHWAttrs[key].CS.Port)) == null ? '' : __t) +
'_' +
((__t = (sdSpiHWAttrs[key].CS.Pin)) == null ? '' : __t) +
'_CS,\n    },\n';
   }
;
__p += '};\n\nconst SDSPI_Config SDSPI_config[Board_SDSPICOUNT] = {\n';
  for(var key in sdSpiHWAttrs) {
;
__p += '    {\n        .fxnTablePtr = &SDSPIMSP432_fxnTable,\n        .object = &sdspiMSP432Objects[' +
((__t = (sdSpiHWAttrs[key].ReqName)) == null ? '' : __t) +
'],\n        .hwAttrs = &sdspiMSP432HWAttrs[' +
((__t = (sdSpiHWAttrs[key].ReqName)) == null ? '' : __t) +
']\n    },\n';
   }
;
__p += '};\n\nconst uint_least8_t SDSPI_count = Board_SDSPICOUNT;\n';
  }
  if(Object.keys(spiHWAttrs).length > 0) {
;
__p += '\n/*\n *  =============================== SPI ===============================\n */\n#include <ti/drivers/SPI.h>\n#include <ti/drivers/spi/SPIMSP432DMA.h>\n\n/* SPI objects */\nSPIMSP432DMA_Object spiMSP432DMAObjects[Board_SPICOUNT];\n\n/* SPI configuration structure */\nconst SPIMSP432DMA_HWAttrsV1 spiMSP432DMAHWAttrs[Board_SPICOUNT] = {\n';
  var i = 0;
  for( var key in spiHWAttrs) {
;
__p += '    {\n        .baseAddr = ' +
((__t = (spiHWAttrs[key].BaseAddr)) == null ? '' : __t) +
',\n        .bitOrder = ' +
((__t = (spiHWAttrs[key].BitOrder)) == null ? '' : __t) +
',\n        .clockSource = ' +
((__t = (spiHWAttrs[key].ClockSource)) == null ? '' : __t) +
',\n        .defaultTxBufValue = 0,\n        .dmaIntNum = INT_DMA_INT' +
((__t = (++i)) == null ? '' : __t) +
',\n        .intPriority = (~0),\n        .rxDMAChannelIndex = ' +
((__t = (dmaSPIChannel[spiHWAttrs[key].BaseAddr][0])) == null ? '' : __t) +
',\n        .txDMAChannelIndex = ' +
((__t = (dmaSPIChannel[spiHWAttrs[key].BaseAddr][1])) == null ? '' : __t) +
',\n        .clkPin = SPIMSP432DMA_P' +
((__t = (spiHWAttrs[key].CLK.Port)) == null ? '' : __t) +
'_' +
((__t = (spiHWAttrs[key].CLK.Pin)) == null ? '' : __t) +
'_' +
((__t = (spiHWAttrs[key].CLK.Mode)) == null ? '' : __t) +
',\n        .simoPin = SPIMSP432DMA_P' +
((__t = (spiHWAttrs[key].SIMO.Port)) == null ? '' : __t) +
'_' +
((__t = (spiHWAttrs[key].SIMO.Pin)) == null ? '' : __t) +
'_' +
((__t = (spiHWAttrs[key].SIMO.Mode)) == null ? '' : __t) +
',\n        .somiPin = SPIMSP432DMA_P' +
((__t = (spiHWAttrs[key].SOMI.Port)) == null ? '' : __t) +
'_' +
((__t = (spiHWAttrs[key].SOMI.Pin)) == null ? '' : __t) +
'_' +
((__t = (spiHWAttrs[key].SOMI.Mode)) == null ? '' : __t) +
',\n        .stePin = SPIMSP432DMA_P' +
((__t = (spiHWAttrs[key].STE.Port)) == null ? '' : __t) +
'_' +
((__t = (spiHWAttrs[key].STE.Pin)) == null ? '' : __t) +
'_' +
((__t = (spiHWAttrs[key].STE.Mode)) == null ? '' : __t) +
',\n        .pinMode = ' +
((__t = (spiHWAttrs[key].PinMode)) == null ? '' : __t) +
'\n    },\n';
   }
;
__p += '};\n\nconst SPI_Config SPI_config[Board_SPICOUNT] = {\n';
  for(var key in spiHWAttrs) {
;
__p += '    {\n        .fxnTablePtr = &SPIMSP432DMA_fxnTable,\n        .object = &spiMSP432DMAObjects[' +
((__t = (spiHWAttrs[key].ReqName)) == null ? '' : __t) +
'],\n        .hwAttrs = &spiMSP432DMAHWAttrs[' +
((__t = (spiHWAttrs[key].ReqName)) == null ? '' : __t) +
']\n    },\n';
   }
;
__p += '};\n\nconst uint_least8_t SPI_count = Board_SPICOUNT;\n';
  }
  if((Object.keys(timerHWAttrs).length > 0) || (Object.keys(timer32HWAttrs).length > 0)) {
;
__p += '/*\n *  =============================== Timer ===============================\n */\n#include <ti/drivers/Timer.h>\n#include <ti/drivers/timer/TimerMSP432.h>\n\nTimerMSP432_Object timerMSP432Objects[Board_TIMERCOUNT];\n\nconst TimerMSP432_HWAttrs timerMSP432HWAttrs[Board_TIMERCOUNT] = {\n';
  for( var key in timer32HWAttrs) {
;
__p += '    {\n        .timerBaseAddress = ' +
((__t = (timer32HWAttrs[key].BaseAddr)) == null ? '' : __t) +
',\n        .clockSource = ' +
((__t = (timer32HWAttrs[key].ClockSource)) == null ? '' : __t) +
',\n        .intNum = ' +
((__t = (intTable[timer32HWAttrs[key].BaseAddr])) == null ? '' : __t) +
',\n        .intPriority = ~0\n    },\n';
   }
  for( var key in timerHWAttrs) {
;
__p += '    {        \n        .timerBaseAddress = ' +
((__t = (timerHWAttrs[key].BaseAddr)) == null ? '' : __t) +
',\n        .clockSource = ' +
((__t = (timerHWAttrs[key].ClockSource)) == null ? '' : __t) +
',\n        .intNum = ' +
((__t = (intTable[timerHWAttrs[key].BaseAddr])) == null ? '' : __t) +
',\n        .intPriority = ~0\n    },\n';
   }
;
__p += '};\n\nconst Timer_Config Timer_config[Board_TIMERCOUNT] = {\n';
  for(var key in timer32HWAttrs) {
;
__p += '    {\n        .fxnTablePtr = &TimerMSP432_Timer32_fxnTable,\n        .object = &timerMSP432Objects[' +
((__t = (timer32HWAttrs[key].ReqName)) == null ? '' : __t) +
'],\n        .hwAttrs = &timerMSP432HWAttrs[' +
((__t = (timer32HWAttrs[key].ReqName)) == null ? '' : __t) +
']\n    },\n';
   }
   for(var key in timerHWAttrs) {
;
__p += '    {\n        .fxnTablePtr = &TimerMSP432_Timer_A_fxnTable,\n        .object = &timerMSP432Objects[' +
((__t = (timerHWAttrs[key].ReqName)) == null ? '' : __t) +
'],\n        .hwAttrs = &timerMSP432HWAttrs[' +
((__t = (timerHWAttrs[key].ReqName)) == null ? '' : __t) +
']\n    },\n';
   }
;
__p += '};\n\nconst uint_least8_t Timer_count = Board_TIMERCOUNT;\n';
  }
  if((Object.keys(uartHWAttrs).length > 0) || (Object.keys(displayHWAttrs).length > 0)) {
;
__p += '\n/*\n *  =============================== UART ===============================\n */\n#include <ti/drivers/UART.h>\n#include <ti/drivers/uart/UARTMSP432.h>\n\nUARTMSP432_Object uartMSP432Objects[Board_UARTCOUNT];\nunsigned char uartMSP432RingBuffer[Board_UARTCOUNT][32];\n\n/*\n * The baudrate dividers were determined by using the MSP432 baudrate\n * calculator\n * http://software-dl.ti.com/msp430/msp430_public_sw/mcu/msp430/MSP430BaudRateConverter/index.html\n */\nconst UARTMSP432_BaudrateConfig uartMSP432Baudrates[] = {\n    /* {baudrate, input clock, prescalar, UCBRFx, UCBRSx, oversampling} */\n    {\n        .outputBaudrate = 115200,\n        .inputClockFreq = 12000000,\n        .prescalar = 6,\n        .hwRegUCBRFx = 8,\n        .hwRegUCBRSx = 32,\n        .oversampling = 1\n    },\n    {115200, 6000000,   3,  4,   2, 1},\n    {115200, 3000000,   1, 10,   0, 1},\n    {9600,   12000000, 78,  2,   0, 1},\n    {9600,   6000000,  39,  1,   0, 1},\n    {9600,   3000000,  19,  8,  85, 1},\n    {9600,   32768,     3,  0, 146, 0}\n};\n\nconst UARTMSP432_HWAttrsV1 uartMSP432HWAttrs[Board_UARTCOUNT] = {\n';
  for( var key in displayHWAttrs) {
;
__p += '    {\n        .baseAddr = ' +
((__t = (displayHWAttrs[key].BaseAddr)) == null ? '' : __t) +
',\n        .intNum = ' +
((__t = (intTable[displayHWAttrs[key].BaseAddr])) == null ? '' : __t) +
',\n        .intPriority = (~0),\n        .clockSource = ' +
((__t = (displayHWAttrs[key].ClockSource)) == null ? '' : __t) +
',\n        .bitOrder = ' +
((__t = (displayHWAttrs[key].BitOrder)) == null ? '' : __t) +
',\n        .numBaudrateEntries = sizeof(uartMSP432Baudrates) /\n            sizeof(UARTMSP432_BaudrateConfig),\n        .baudrateLUT = uartMSP432Baudrates,\n        .ringBufPtr  = uartMSP432RingBuffer[' +
((__t = (displayHWAttrs[key].ReqName)) == null ? '' : __t) +
'],\n        .ringBufSize = sizeof(uartMSP432RingBuffer[' +
((__t = (displayHWAttrs[key].ReqName)) == null ? '' : __t) +
']),\n        .rxPin = UARTMSP432_P' +
((__t = (displayHWAttrs[key]["RXD"]["Port"])) == null ? '' : __t) +
'_' +
((__t = (displayHWAttrs[key]["RXD"]["Pin"])) == null ? '' : __t) +
'_' +
((__t = (displayHWAttrs[key]["RXD"]["Mode"])) == null ? '' : __t) +
',\n        .txPin = UARTMSP432_P' +
((__t = (displayHWAttrs[key]["TXD"]["Port"])) == null ? '' : __t) +
'_' +
((__t = (displayHWAttrs[key]["TXD"]["Pin"])) == null ? '' : __t) +
'_' +
((__t = (displayHWAttrs[key]["TXD"]["Mode"])) == null ? '' : __t) +
',\n    },\n';
   }
  for( var key in uartHWAttrs) {
;
__p += '    {\n        .baseAddr = ' +
((__t = (uartHWAttrs[key].BaseAddr)) == null ? '' : __t) +
',\n        .intNum = ' +
((__t = (intTable[uartHWAttrs[key].BaseAddr])) == null ? '' : __t) +
',\n        .intPriority = (~0),\n        .clockSource = ' +
((__t = (uartHWAttrs[key].ClockSource)) == null ? '' : __t) +
',\n        .bitOrder = ' +
((__t = (uartHWAttrs[key].BitOrder)) == null ? '' : __t) +
',\n        .numBaudrateEntries = sizeof(uartMSP432Baudrates) /\n            sizeof(UARTMSP432_BaudrateConfig),\n        .baudrateLUT = uartMSP432Baudrates,\n        .ringBufPtr  = uartMSP432RingBuffer[' +
((__t = (uartHWAttrs[key].ReqName)) == null ? '' : __t) +
'],\n        .ringBufSize = sizeof(uartMSP432RingBuffer[' +
((__t = (uartHWAttrs[key].ReqName)) == null ? '' : __t) +
']),\n        .rxPin = UARTMSP432_P' +
((__t = (uartHWAttrs[key]["RXD"]["Port"])) == null ? '' : __t) +
'_' +
((__t = (uartHWAttrs[key]["RXD"]["Pin"])) == null ? '' : __t) +
'_' +
((__t = (uartHWAttrs[key]["RXD"]["Mode"])) == null ? '' : __t) +
',\n        .txPin = UARTMSP432_P' +
((__t = (uartHWAttrs[key]["TXD"]["Port"])) == null ? '' : __t) +
'_' +
((__t = (uartHWAttrs[key]["TXD"]["Pin"])) == null ? '' : __t) +
'_' +
((__t = (uartHWAttrs[key]["TXD"]["Mode"])) == null ? '' : __t) +
',\n    },\n';
   }
;
__p += '};\n\nconst UART_Config UART_config[Board_UARTCOUNT] = {\n';
  for(var key in displayHWAttrs) {
;
__p += '    {\n        .fxnTablePtr = &UARTMSP432_fxnTable,\n        .object = &uartMSP432Objects[' +
((__t = (displayHWAttrs[key].ReqName)) == null ? '' : __t) +
'],\n        .hwAttrs = &uartMSP432HWAttrs[' +
((__t = (displayHWAttrs[key].ReqName)) == null ? '' : __t) +
']\n    }\n';
   }
  for(var key in uartHWAttrs) {
;
__p += '    {\n        .fxnTablePtr = &UARTMSP432_fxnTable,\n        .object = &uartMSP432Objects[' +
((__t = (uartHWAttrs[key].ReqName)) == null ? '' : __t) +
'],\n        .hwAttrs = &uartMSP432HWAttrs[' +
((__t = (uartHWAttrs[key].ReqName)) == null ? '' : __t) +
']\n    },\n';
   }
;
__p += '};\n\nconst uint_least8_t UART_count = Board_UARTCOUNT;\n';
  }
  if(Object.keys(watchdogHWAttrs).length > 0) {
;
__p += '    \n/*\n *  =============================== Watchdog ===============================\n */\n#include <ti/drivers/Watchdog.h>\n#include <ti/drivers/watchdog/WatchdogMSP432.h>\n\nWatchdogMSP432_Object watchdogMSP432Objects[Board_WATCHDOGCOUNT];\n\nconst WatchdogMSP432_HWAttrs watchdogMSP432HWAttrs[Board_WATCHDOGCOUNT] = {\n';
   for (var key in watchdogHWAttrs) {
;
__p += '    {\n        .baseAddr = ' +
((__t = (watchdogHWAttrs[key].BaseAddr)) == null ? '' : __t) +
',\n        .intNum = ' +
((__t = (intTable[watchdogHWAttrs[key].BaseAddr])) == null ? '' : __t) +
',\n        .intPriority = (~0),\n        .clockSource = ' +
((__t = (watchdogHWAttrs[key].ClockSource)) == null ? '' : __t) +
',\n        .clockDivider = ' +
((__t = (watchdogHWAttrs[key].ClockDivider)) == null ? '' : __t) +
'\n    },\n';
   }
;
__p += '};\n\nconst Watchdog_Config Watchdog_config[Board_WATCHDOGCOUNT] = {\n';
   for (var key in watchdogHWAttrs) {
;
__p += '    {\n        .fxnTablePtr = &WatchdogMSP432_fxnTable,\n        .object = &watchdogMSP432Objects[' +
((__t = (watchdogHWAttrs[key].ReqName)) == null ? '' : __t) +
'],\n        .hwAttrs = &watchdogMSP432HWAttrs[' +
((__t = (watchdogHWAttrs[key].ReqName)) == null ? '' : __t) +
']\n    },\n';
   }
;
__p += '};\n\nconst uint_least8_t Watchdog_count = Board_WATCHDOGCOUNT;\n';
  }
;

return __p
}; });
defineResource("/MSP432P401R/templates/Drivers/Board.h.xdt", function(_, system, pmux, scripting, require) { "use strict";return function(args) {
var __t, __p = '', __j = Array.prototype.join;
function print() { __p += __j.call(arguments, '') }

 var $legacy = pmux.getScript("/legacy/adapt.js")(pmux), assignmentErrors = $legacy.assignmentErrors, assignments = $legacy.assignments, peripheralConfigurables = $legacy.peripheralConfigurables, peripheralConfigurations = $legacy.peripheralConfigurations, selectedUseCases = $legacy.selectedUseCases, version = $legacy.version, deviceData = $legacy.deviceData;
;
__p += '//*****************************************************************************\n// Board.h\n//\n// configure the device pins for different signals\n//\n// Copyright (C) 2015 Texas Instruments Incorporated - http://www.ti.com/ \n// \n// \n//  Redistribution and use in source and binary forms, with or without \n//  modification, are permitted provided that the following conditions \n//  are met:\n//\n//    Redistributions of source code must retain the above copyright \n//    notice, this list of conditions and the following disclaimer.\n//\n//    Redistributions in binary form must reproduce the above copyright\n//    notice, this list of conditions and the following disclaimer in the \n//    documentation and/or other materials provided with the   \n//    distribution.\n//\n//    Neither the name of Texas Instruments Incorporated nor the names of\n//    its contributors may be used to endorse or promote products derived\n//    from this software without specific prior written permission.\n//\n//  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \n//  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT \n//  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n//  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT \n//  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, \n//  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT \n//  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n//  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n//  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT \n//  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE \n//  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//\n//*****************************************************************************\n\n';
 var date = new Date();
;
__p += '// This file was automatically generated on ' +
((__t = (date.toLocaleDateString())) == null ? '' : __t) +
' at ' +
((__t = (date.toLocaleTimeString())) == null ? '' : __t) +
'\n// by TI PinMux version ' +
((__t = (version)) == null ? '' : __t) +
'\n//\n//*****************************************************************************\n';

    var boardADC = [];
    var boardADCBuf = {};
    var boardADCBufChannel = [];
    var boardCapture = {};
    var boardDisplay = {};
    var boardSDSPI = {};
    var boardSPI = {};
    var boardUART = {};
    var boardI2C = {};
    var boardI2CSlave = {};
    var boardGPIO = [];
    var boardPWM = [];
    var boardTimer = {};
    var boardTimer32 = {};
    var boardWatchdog = {};

    function strContains(str,substr){
        return str.indexOf(substr) !== -1;
    }

    for( var i = 0; i < assignments.length; i++ ) { //by pin
        if (assignments[i].interfaceName.match(/^GPIO/gi)) {
            /*
            Example: if requirement name is Board_BUTTON
            if none existed before, adding one GPIO pin produces Board_BUTTON
            if one existed before, adding one more GPIO pin produces Board_BUTTON1 and changes old to Board_BUTTON0
            else, any more added will begin to increment Board_BUTTON2, Board_BUTTON3, etc.
            */
            var reqName = assignments[i].requirementName;
            var numOccurrences = _.reduce(boardGPIO,function(num, name) {
                 return num + (strContains(name,reqName));
            }, 0);
            if(numOccurrences == 0)
            {
                boardGPIO.push(reqName);
            }
            else if(numOccurrences == 1)
            {
                boardGPIO[boardGPIO.indexOf(reqName)] += '0';
                boardGPIO.push(reqName + numOccurrences);
            }
            else
            {
                boardGPIO.push(reqName + numOccurrences);
            }
        }
        else if (assignments[i].interfaceName.match(/^ADC/gi)) {
            if(assignments[i].peripheralPin.interfacePin.name.match(/A[0-9]{1,2}/) == null)
            {
                //skip VREF+, VREF-, VeREF+, or VeREF-
                continue;
            }
            if(selectedUseCases[assignments[i].requirementName].name == "106_usecase_101")  //ADC
            {
                boardADC.push(assignments[i].requirementName + assignments[i].peripheralPin.interfacePin.name.match(/[^A]{1,2}$/gi));
            }
            else    //ADCBuf
            {
                var reqName = assignments[i].requirementName;
                if (boardADCBuf[reqName] == null) {
                    boardADCBuf[reqName] = reqName;
                }
                boardADCBufChannel.push(boardADCBuf[reqName] + 'CHANNEL' + assignments[i].peripheralPin.interfacePin.name.match(/[^A]{1,2}$/gi));
                reqName += "_TIMER";
                if (boardTimer[reqName] == null) {
                    boardTimer[reqName] = reqName;
                }
            }
        }
        else if (assignments[i].interfaceName.match(/^I2C/gi)) {
            var reqName = assignments[i].requirementName;
            if (selectedUseCases[assignments[i].requirementName].name == "103_usecase_101")  //i2cMaster
            {
                if (boardI2C[reqName] == null) {
                    boardI2C[reqName] = reqName;
                }
            }
            else {  //i2cSlave
                if (boardI2CSlave[reqName] == null) {
                    boardI2CSlave[reqName] = reqName;
                }
            }
        }
        else if (assignments[i].interfaceName.match(/^SPI/gi)) {
            var reqName = assignments[i].requirementName;
            if(selectedUseCases[assignments[i].requirementName].name == "101_usecase_102")  //sdSpi
            {
                if (boardSDSPI[reqName] == null) {
                    boardSDSPI[reqName] = reqName;
                }
            }
            else    //spi
            {
                if (boardSPI[reqName] == null) {
                    boardSPI[reqName] = reqName;
                }
            }
        }
        else if (assignments[i].interfaceName.match(/^UART/gi)) {
            var reqName = assignments[i].requirementName;
            if (boardUART[reqName] == null) {
                boardUART[reqName] = reqName;
            }
        }
        else if (assignments[i].interfaceName.match(/^TIMER_A/gi)) {
            var reqName = assignments[i].requirementName;
            if (selectedUseCases[assignments[i].requirementName].name == "104_usecase_102")    //PWM
            {
                boardPWM.push(reqName + "_" + assignments[i].peripheralPin.name.split('.')[1]);
            }
            else if (selectedUseCases[assignments[i].requirementName].name == "104_usecase_103")    //Capture
            {
                if (boardCapture[reqName] != null) {
                    throw new Error("Capture only allows one active CCI pin per module!");
                }
                if (boardCapture[reqName] == null) {
                    boardCapture[reqName] = reqName;
                }
            }
        }
    }
    
    for (var i = 0; i < peripheralConfigurables.length; i++)    //by driver
    {
        if (peripheralConfigurables[i].interfaceName.match(/^TIMER_A/gi)) {
            var reqName = peripheralConfigurables[i].requirementName;
            if (selectedUseCases[peripheralConfigurables[i].requirementName].name != "104_usecase_101") //not Timer
            {
                reqName += "_TIMER";
            }
            if (boardTimer[reqName] == null) {
                boardTimer[reqName] = reqName;
            }
        }
        else if (peripheralConfigurables[i].interfaceName.match(/^TIMER32/gi)) {
            var reqName = peripheralConfigurables[i].requirementName;
            if(boardTimer32[reqName] == null) {
                boardTimer32[reqName] = reqName;
            }
        }
        else if (peripheralConfigurables[i].interfaceName.match(/^WATCHDOG/gi)) {
            var reqName = peripheralConfigurables[i].requirementName;
            if(boardWatchdog[reqName] == null) {
                boardWatchdog[reqName] = reqName;
            }
        }
        else if (peripheralConfigurables[i].interfaceName.match(/^DISPLAY/gi)) {
            var reqName = peripheralConfigurables[i].requirementName;
            if(boardDisplay[reqName] == null) {
                boardDisplay[reqName] = reqName;
            }
        }
    }
;
__p += '#ifndef __BOARD_H__\n#define __BOARD_H__\n\n#ifdef __cplusplus\nextern "C" {\n#endif\n\n/* LEDs on MSP_EXP432P401R are active high. */\n#define Board_GPIO_LED_OFF (0)\n#define Board_GPIO_LED_ON  (1)\n\n#define Board_initADC               ADC_init\n#define Board_initADCBuf            ADCBuf_init\n#define Board_initGeneral           MSP_EXP432P401R_initGeneral\n#define Board_initGPIO              GPIO_init\n#define Board_initI2C               I2C_init\n#define Board_initPWM               PWM_init\n#define Board_initSDSPI             SDSPI_init\n#define Board_initSPI               SPI_init\n#define Board_initUART              UART_init\n#define Board_initWatchdog          Watchdog_init\n\n/* Board specific I2C addresses */\n#define Board_TMP_ADDR              (0x40)\n#define Board_RF430CL330_ADDR       (0x28)\n#define Board_TPL0401_ADDR          (0x40)\n';
  if(boardADC.length > 0) {
;
__p += '\n/*!\n *  @def    MSP_EXP432P401R_ADCName\n *  @brief  Enum of ADC channels on the MSP_EXP432P401R dev board\n */\ntypedef enum Board_ADCName {\n';
  for(var i=0; i<boardADC.length; i++) {
;
__p += '    ' +
((__t = (boardADC[i])) == null ? '' : __t) +
' = ' +
((__t = (i)) == null ? '' : __t) +
',\n';
   }
;
__p += '    Board_ADCCOUNT\n} Board_ADCName;\n';
  }
  if(Object.keys(boardADCBuf).length > 0) {
;
__p += '\n/*!\n *  @def    MSP_EXP432P401R_ADCBufName\n *  @brief  Enum of ADCBuf hardware peripherals on the MSP_EXP432P401R dev board\n */\n typedef enum Board_ADCBufName {\n';
  var i = 0;
  for(var key in boardADCBuf) {
;
__p += '    ' +
((__t = (boardADCBuf[key])) == null ? '' : __t) +
' = ' +
((__t = (i++)) == null ? '' : __t) +
',\n';
   }
;
__p += '    Board_ADCBUFCOUNT\n } Board_ADCBufName;\n\n    \n/*!\n *  @def    MSP_EXP432P401R_ADCBufChannelName\n *  @brief  Enum of ADCBuf channels on the MSP_EXP432P401R dev board\n */\n typedef enum Board_ADCBuf0ChannelName {\n';
  for(var i=0; i<boardADCBufChannel.length; i++) {
;
__p += '    ' +
((__t = (boardADCBufChannel[i])) == null ? '' : __t) +
' = ' +
((__t = (i)) == null ? '' : __t) +
',\n';
   }
;
__p += '    Board_ADCBUF0CHANNELCOUNT\n } Board_ADCBuf0ChannelName;\n';
  }
  if(Object.keys(boardCapture).length > 0) {
;
__p += '    \n/*!\n *  @def    MSP_EXP432P401R_CaptureName\n *  @brief  Enum of Capture timer names on the MSP_EXP432P401R dev board\n */\n typedef enum Board_CaptureName {\n';
  var i = 0;
  for(var key in boardCapture) {
;
__p += '    ' +
((__t = (boardCapture[key])) == null ? '' : __t) +
' = ' +
((__t = (i++)) == null ? '' : __t) +
',\n';
 }
;
__p += '    Board_CAPTURECOUNT\n} Board_CaptureName;\n';
  }
  if(boardGPIO.length > 0) {
;
__p += '\n/*!\n *  @def    MSP_EXP432P401R_GPIOName\n *  @brief  Enum of GPIO names on the MSP_EXP432P401R dev board\n */\ntypedef enum Board_GPIOName {\n';
  for(var i=0; i<boardGPIO.length; i++) {
;
__p += '    ' +
((__t = (boardGPIO[i])) == null ? '' : __t) +
' = ' +
((__t = (i)) == null ? '' : __t) +
',\n';
   }
;
__p += '    Board_GPIOCOUNT\n} Board_GPIOName;\n';
  }
  if(Object.keys(boardI2C).length > 0) {
;
__p += '\n/*!\n *  @def    MSP_EXP432P401R_I2CName\n *  @brief  Enum of I2C names on the MSP_EXP432P401R dev board\n */\ntypedef enum Board_I2CName {\n';
  var i = 0;
  for(var key in boardI2C) {
;
__p += '    ' +
((__t = (boardI2C[key])) == null ? '' : __t) +
' = ' +
((__t = (i++)) == null ? '' : __t) +
',\n';
  }
;
__p += '   Board_I2CCOUNT\n} Board_I2CName;\n';
  }
  if(Object.keys(boardI2CSlave).length > 0) {
;
__p += '    \n/*!\n *  @def    MSP_EXP432P401R_I2CSlaveName\n *  @brief  Enum of I2CSlave names on the MSP_EXP432P401R dev board\n */\n typedef enum Board_I2CSlaveName {\n';
   var i = 0;
   for(var key in boardI2CSlave) {
;
__p += '    ' +
((__t = (boardI2CSlave[key])) == null ? '' : __t) +
' = ' +
((__t = (i++)) == null ? '' : __t) +
',\n';
   }
;
__p += '    Board_I2CSLAVECOUNT\n} Board_I2CSlaveName;\n';
  }
  if(boardPWM.length > 0) {
;
__p += '\n/*!\n *  @def    MSP_EXP432P401R_PWMName\n *  @brief  Enum of PWM names on the MSP_EXP432P401R dev board\n */\ntypedef enum Board_PWMName {\n';
  for(var i=0; i<boardPWM.length; i++) {
;
__p += '    ' +
((__t = (boardPWM[i])) == null ? '' : __t) +
' = ' +
((__t = (i)) == null ? '' : __t) +
',\n';
    }
;
__p += '    Board_PWMCOUNT\n} Board_PWMName;\n';
  }
  if(Object.keys(boardSDSPI).length > 0) {
;
__p += '    \n/*!\n *  @def    MSP_EXP432P401R_SDSPIName\n *  @brief  Enum of SDSPI names on the MSP_EXP432P401R dev board\n */\n typedef enum Board_SDSPIName {\n';
  var i = 0;
  for(var key in boardSDSPI) {
;
__p += '    ' +
((__t = (boardSDSPI[key])) == null ? '' : __t) +
' = ' +
((__t = (i++)) == null ? '' : __t) +
',\n';
   }
;
__p += '    Board_SDSPICOUNT\n} Board_SDSPIName;\n';
  }
  if(Object.keys(boardSPI).length > 0) {
;
__p += '\n/*!\n *  @def    MSP_EXP432P401R_SPIName\n *  @brief  Enum of SPI names on the MSP_EXP432P401R dev board\n */\ntypedef enum Board_SPIName {\n';
  var i = 0;
  for(var key in boardSPI) {
;
__p += '    ' +
((__t = (boardSPI[key])) == null ? '' : __t) +
' = ' +
((__t = (i++)) == null ? '' : __t) +
',\n';
  }
;
__p += '   Board_SPICOUNT\n} Board_SPIName;\n';
  }
  if((Object.keys(boardTimer).length > 0) || (Object.keys(boardTimer32).length > 0)) {
;
__p += '    \n/*!\n *  @def    MSP_EXP432P401R_TimerName\n *  @brief  Enum of Timer names on the MSP_EXP432P401R dev board\n */\ntypedef enum Board_TimerName {\n';
  var i = 0;
  for(var key in boardTimer32) {
;
__p += '    ' +
((__t = (boardTimer32[key])) == null ? '' : __t) +
' = ' +
((__t = (i++)) == null ? '' : __t) +
',\n';
  }
  for(var key in boardTimer) {
;
__p += '    ' +
((__t = (boardTimer[key])) == null ? '' : __t) +
' = ' +
((__t = (i++)) == null ? '' : __t) +
',\n';
  }
;
__p += '   Board_TIMERCOUNT\n} Board_TimerName;\n';
  }
  if((Object.keys(boardUART).length > 0) || (Object.keys(boardDisplay).length > 0)) {
;
__p += '\n/*!\n *  @def    MSP_EXP432P401R_UARTName\n *  @brief  Enum of UART names on the MSP_EXP432P401R dev board\n */\ntypedef enum Board_UARTName {\n';
  var i = 0;
  for( var key in boardDisplay) {
;
__p += '    ' +
((__t = (boardDisplay[key])) == null ? '' : __t) +
' = ' +
((__t = (i++)) == null ? '' : __t) +
',\n';
  }
  for( var key in boardUART) {
;
__p += '    ' +
((__t = (boardUART[key])) == null ? '' : __t) +
' = ' +
((__t = (i++)) == null ? '' : __t) +
',\n';
  }
;
__p += '    Board_UARTCOUNT\n} Board_UARTName;\n';
  }
;
__p += '    \n';
  if(Object.keys(boardWatchdog).length > 0) {
;
__p += '/*!\n *  @def    MSP_EXP432P401R_WatchdogName\n *  @brief  Enum of Watchdog names on the MSP_EXP432P401R dev board\n */\ntypedef enum Board_WatchdogName {\n';
  var i = 0;
  for( var key in boardWatchdog) {
;
__p += '    ' +
((__t = (boardWatchdog[key])) == null ? '' : __t) +
' = ' +
((__t = (i++)) == null ? '' : __t) +
',\n';
  }
;
__p += '   Board_WATCHDOGCOUNT\n} Board_WatchdogName;\n';
  }
;
__p += '\n/*!\n *  @brief  Initialize the general board specific settings\n *\n *  This function initializes the general board specific settings.\n */\nextern void Board_initGeneral(void);\n\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif /* __BOARD_H__ */\n';
return __p
}; });