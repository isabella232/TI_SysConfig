// This bundle was auto-generated on 2021-1-5 at 20:17:49
// From the folders: 
// /home/xgbsesvc/jenkins/workspace/sysconfig.build.installers/pinmux/out/dist/deviceData/AMIC110
defineResource("/AMIC110/templates/csv/PinmuxConfigSummary.csv.xdt", function(_, system, pmux, scripting, require) { "use strict";return function(args) {
var __t, __p = '', __j = Array.prototype.join;
function print() { __p += __j.call(arguments, '') }

 var $legacy = pmux.getScript("/legacy/adapt.js")(pmux), assignments = $legacy.assignments;


var parseMux = function ( thisMux ) {
	if (thisMux == 8 || thisMux == 9) {
		thisMux = 3;
	}
	return thisMux;
};

;
__p += 'Design Signal Pad Name,IO Power Group,PUPD State During HHV,PUPD State After HHV,IO Power Supply Name,IO Power Setting,Required Voltage Level,Ball Name,Selected Mode Number,Mode Interface Name,Mode Signal Name,Mode Type,User Checked PU,User Checked PD,User Checked RX,User Requirement Name\n';
 for( var i = 0; i < assignments.length; ++i ) {
;
__p +=
((__t = (assignments[i].devicePin.designSignalName)) == null ? '' : __t) +
',' +
((__t = (assignments[i].devicePin.powerDomain.powerGroup)) == null ? '' : __t) +
',' +
((__t = (assignments[i].devicePin.pupdStateDuringHHV)) == null ? '' : __t) +
',' +
((__t = (assignments[i].devicePin.pupdStateAfterHHV)) == null ? '' : __t) +
',' +
((__t = (assignments[i].devicePin.powerDomain.name)) == null ? '' : __t) +
',' +
((__t = (assignments[i].powerSetting)) == null ? '' : __t) +
',' +
((__t = (assignments[i].requiredVoltageLevel)) == null ? '' : __t) +
',' +
((__t = (assignments[i].devicePin.ball)) == null ? '' : __t) +
',' +
((__t = (parseMux(assignments[i].muxMode))) == null ? '' : __t) +
',' +
((__t = (assignments[i].peripheral.name)) == null ? '' : __t) +
',' +
((__t = (assignments[i].peripheralPin.name)) == null ? '' : __t) +
',' +
((__t = (assignments[i].peripheralPin.interfacePin.receiver)) == null ? '' : __t) +
',' +
((__t = (assignments[i].pu)) == null ? '' : __t) +
',' +
((__t = (assignments[i].pd)) == null ? '' : __t) +
',' +
((__t = (assignments[i].rx)) == null ? '' : __t) +
',' +
((__t = (assignments[i].requirementName)) == null ? '' : __t) +
'\n';
 }
;

return __p
}; });
defineResource("/AMIC110/templates/devicetree/devicetree.dtsi.xdt", function(_, system, pmux, scripting, require) { "use strict";return function(args) {
var __t, __p = '', __j = Array.prototype.join;
function print() { __p += __j.call(arguments, '') }

 var $legacy = pmux.getScript("/legacy/adapt.js")(pmux), assignments = $legacy.assignments;

var groupedAssignments = {};
var notUsedAssignments = {};
var printSMA2 = 0;
_( assignments ).each( function( assignment ) {
	// Use the requirement name as the name, but lower case and _ instead of spaces
	
	var requirementName = assignment.requirementName.toLowerCase().replace( / /g, "_" );
	if( "NOT FOUND" !== assignment.devicePin.controlRegisterOffset ) {
		groupedAssignments[ assignment.interfaceName ] = groupedAssignments[ assignment.interfaceName ] || {};
		groupedAssignments[ assignment.interfaceName ][ requirementName ] = groupedAssignments[ assignment.interfaceName ][ requirementName ] || [];
		groupedAssignments[ assignment.interfaceName ][ requirementName ].push( assignment );
	} else {
		notUsedAssignments[ assignment.interfaceName ] = notUsedAssignments[ assignment.interfaceName ] || {};
		notUsedAssignments[ assignment.interfaceName ][ requirementName ] = {};
	}
} );

var getOffset = function( assignment ) {
	return "0x" + ( assignment.devicePin.controlRegisterOffset - 0x0 ).toString( 16 ).toLowerCase();
};

var getPinConfig = function( assignment ) {
	var result = "";
	if( assignment.rx ) {
		if( assignment.pu ) {
			result += "PIN_INPUT_PULLUP | ";
		}
		else if( assignment.pd ) {
			result += "PIN_INPUT_PULLDOWN | ";
		}
		else {
			result += "PIN_INPUT | ";
		}
	} else {
		if( assignment.pu ) {
			result += "PIN_OUTPUT_PULLUP | ";
		}
		else if( assignment.pd ) {
			result += "PIN_OUTPUT_PULLDOWN | ";
		}
		else {
			result += "PIN_OUTPUT | ";
		}
	}
	var pinMuxMode = assignment.muxMode;
	if (9 == pinMuxMode) {
		pinMuxMode = 3;
		printSMA2 = 0;
	} else if ( 8 == pinMuxMode) {
		pinMuxMode = 3;
		printSMA2 = 1;
	}
	result += "MUX_MODE" + pinMuxMode;
	return result;
};

var getPinComment = function( assignment ) {
	return "/* (" + assignment.devicePin.ball + ") " + assignment.devicePin.designSignalName + "." + assignment.peripheralPin.name + " */";
};

var date = new Date();

;
__p += '/* This file was auto-generated by TI PinMux on ' +
((__t = (date.toLocaleDateString())) == null ? '' : __t) +
' at ' +
((__t = (date.toLocaleTimeString())) == null ? '' : __t) +
'. */\n/* This file should only be used as a reference. Some pins/peripherals, */\n/* depending on your use case, may need additional configuration. */\n\n';
 if( !_( notUsedAssignments ).isEmpty() ) {
;
__p += '/* Some or all the pins from the following groups are not used by device tree \n';
	_( notUsedAssignments ).each( function( iFace ) {
		_( iFace ).each( function( requirement, requirementName ) {
;
__p += '   ' +
((__t = (requirementName)) == null ? '' : __t) +
'\n';
		} );
 	} );
;
__p += '*/\n';
 }
;
__p += '\n&am33xx_pinmux {\n';
	_( groupedAssignments ).each( function( iFace ) {
		_( iFace ).each( function( requirement, requirementName ) {
;
__p += '	' +
((__t = (requirementName)) == null ? '' : __t) +
'_pins_default: ' +
((__t = (requirementName)) == null ? '' : __t) +
'_pins_default {\n		pinctrl-single,pins = <\n';
			_( requirement ).each( function( assignment ) {
;
__p += '			AM33XX_IOPAD(' +
((__t = (getOffset( assignment ))) == null ? '' : __t) +
', ' +
((__t = (getPinConfig( assignment ))) == null ? '' : __t) +
') ' +
((__t = (getPinComment( assignment ))) == null ? '' : __t) +
'\n';
			} );
;
__p += '		>;\n	};\n';
 if( printSMA2 > 0 ) {
;
__p += '	/*\n	 * Warning: to select Pin U16 for gpmc_a9.rmii2_crs_dv requires\n	 * an additional register setting in the Control Module. See "sma2"\n	 * register in TRM subsection "CONTROL_MODULE Registers" for more\n	 * information. The recommended implementation is to write 0x1 to\n	 * the register at the end of board_init() function in u-boot file:\n	 * <source-dir>/board/ti/am335x/board.c\n	 *		int board_init(void) {\n	 *			....\n	 *			u32 reg = readl(CTRL_BASE + 0x1320) | BIT(0);\n	 *			writel(reg, CTRL_BASE + 0x1320);\n	 * 			....\n	 *		}\n	 */\n';
 printSMA2 = 0;
 }
;
__p += '\n	/* Optional sleep pin settings. Must manually enter values in the below skeleton. */\n	' +
((__t = (requirementName)) == null ? '' : __t) +
'_pins_sleep: ' +
((__t = (requirementName)) == null ? '' : __t) +
'_pins_sleep {\n		pinctrl-single,pins = <\n';
			_( requirement ).each( function( assignment ) {
;
__p += '			AM33XX_IOPAD(' +
((__t = (getOffset( assignment ))) == null ? '' : __t) +
',  ) ' +
((__t = (getPinComment( assignment ))) == null ? '' : __t) +
'\n';
			} );
;
__p += '		>;\n	};\n\n';
		} );
	} );
;
__p += '};\n';
return __p
}; });
defineResource("/AMIC110/templates/starterware/amic110_pinmux.h.xdt", function(_, system, pmux, scripting, require) { "use strict";return function(args) {
var __t, __p = '', __j = Array.prototype.join;
function print() { __p += __j.call(arguments, '') }

 var $legacy = pmux.getScript("/legacy/adapt.js")(pmux), deviceData = $legacy.deviceData;
 var date = new Date();
;
__p += '/**\n * Note: This file was auto-generated by TI PinMux on ' +
((__t = (date.toLocaleDateString())) == null ? '' : __t) +
' at ' +
((__t = (date.toLocaleTimeString())) == null ? '' : __t) +
'.\n *\n * \\file   amic110_pinmux.h\n *\n * \\brief  This file contains pad configure register offsets and bit-field \n *         value macros for different configurations,\n *\n *           6    SLEWCTRL       Select between faster or slower slew rate\n *           5    RXACTIVE       Input enable value for the Pad\n *           4    PULLTYPESEL    Pad pullup/pulldown type selection\n *           3    PULLUDEN       Pad pullup/pulldown disable\n *           2-0  MUXMODE        Pad functional signal mux select\n *\n *  \\copyright Copyright (CU) ' +
((__t = (date.getFullYear())) == null ? '' : __t) +
' Texas Instruments Incorporated - \n *             http://www.ti.com/\n */\n\n#ifndef AMIC110_PIN_MUX_H_\n#define AMIC110_PIN_MUX_H_\n\n/* ========================================================================== */\n/*                             Include Files                                  */\n/* ========================================================================== */\n\n#include "pinmux.h"\n\n#ifdef __cplusplus\nextern "C" {\n#endif\n\n/* ========================================================================== */\n/*                           Macros & Typedefs                                */\n/* ========================================================================== */\n#define PIN_MODE(mode)	                (mode)\n\n/** \\brief Active mode configurations */\n/** \\brief Pull up/down disabled */\n#define PIN_PULL_UD_EN	                (0x1U << 3U)  \n/** \\brief Pull UP enable */\n#define	PIN_PULL_TYPE_SEL	            (0x1U << 4U)\n/** \\brief Receiver enable */  \n#define	PIN_RX_ACTIVE	                (0x1U << 5U)\n/** \\brief Slew rate */\n#define PIN_SLEW_SLOW                   (0x1U << 6U)\n\n\n/** \\brief Pad config register offset in control module */\nenum pinOffsets\n{\n';

	var enumStatements = [];	
	_.each( deviceData.devicePins, function( devicePin ) {
		if( undefined !== devicePin.controlRegisterOffset && "NOT FOUND" !== devicePin.controlRegisterOffset ) {
			enumStatements.push( { value : devicePin.controlRegisterOffset + "U", name : "PIN_" + devicePin.designSignalName.toUpperCase() } );
		}
	} );
	enumStatements.push( { value : "0x1320U", name : "SMA2_REGISTER" } );
	enumStatements = _.sortBy( enumStatements, function( statement ) { return statement.value; } );
	var spaces = function( number ) {
		var text = "";
		for( var i = 25 - number; i > 0; --i ) {
			text += " ";
		}
		return text;
	}
;
__p += '	PIN_OFFSET_MIN ' +
((__t = (spaces( "PIN_OFFSET_MIN".length ))) == null ? '' : __t) +
' = ' +
((__t = (enumStatements[ 0 ].value)) == null ? '' : __t) +
',\n';
	for( var i = 0; i < enumStatements.length; ++i ) {
;
__p += '	' +
((__t = (enumStatements[i].name)) == null ? '' : __t) +
' ' +
((__t = (spaces( enumStatements[i].name.length ))) == null ? '' : __t) +
' = ' +
((__t = (enumStatements[i].value)) == null ? '' : __t) +
',\n';
	}
;
__p += '	PIN_OFFSET_MAX ' +
((__t = (spaces( "PIN_OFFSET_MAX".length ))) == null ? '' : __t) +
' = ' +
((__t = (enumStatements[ enumStatements.length - 1 ].value)) == null ? '' : __t) +
'\n};\n\n\n/* ========================================================================== */\n/*                            Global Variables                                */\n/* ========================================================================== */\n\n/** \\brief Auto-generated pinmux configuration data for the board. */\nextern pinmuxBoardCfg_t gAMIC110PinmuxData[];\n\n#ifdef __cplusplus\n}\n#endif /* __cplusplus */\n#endif /* AMIC110_PIN_MUX_H_ */\n';
return __p
}; });
defineResource("/AMIC110/templates/starterware/amic110_pinmux_data.c.xdt", function(_, system, pmux, scripting, require) { "use strict";return function(args) {
var __t, __p = '', __j = Array.prototype.join;
function print() { __p += __j.call(arguments, '') }

 var $legacy = pmux.getScript("/legacy/adapt.js")(pmux), assignments = $legacy.assignments;
 var date = new Date();
;
__p += '/**\n * Note: This file was auto-generated by TI PinMux on ' +
((__t = (date.toLocaleDateString())) == null ? '' : __t) +
' at ' +
((__t = (date.toLocaleTimeString())) == null ? '' : __t) +
'.\n *\n * \\file  amic110_pinmux_data.c\n *\n * \\brief  This file contains the pin mux configurations for the boards.\n *         These are prepared based on how the peripherals are extended on\n *         the boards.\n *\n * \\copyright Copyright (CU) ' +
((__t = (date.getFullYear())) == null ? '' : __t) +
' Texas Instruments Incorporated -\n *             http://www.ti.com/\n */\n\n/* ========================================================================== */\n/*                             Include Files                                  */\n/* ========================================================================== */\n#include "types.h"\n#include "pinmux.h"\n#include "amic110_pinmux.h"\n\n/** Peripheral Pin Configurations */\n\n';

var capitalizeFirstLetterOnly = function( name ) {
    return name[0].toUpperCase() + name.substring( 1, name.length ).toLowerCase();
};

var getMappedInterface = function( assignment ) {
    // The PRUSS is named along with the sub module name. Eg: MII0_PRUSS1,
    // ECAT_PRUSS1, eCAP0_PRUSS1 etc… So where ever you have “PRUSS” as
    // substring the module is PRUSS (PRU_ICSS)

    if( -1 !== assignment.interfaceName.indexOf( "PRUSS" ) ) {
        return "PRU_ICSS";
    }

    // The PWMSS is named only with sub-module names (unlike PRUSS case).
    // Eg: eCAP0, eQEP2, eHRPWM2 etc…. So where ever you are seeing eCAP, eQEP,
    // eHRPWM without PRUSS substring they belong to PWMSS.

    switch( assignment.interfaceName ) {
        case "eCAP":
        case "eQEP":
        case "eHRPWM":
            return "PWMSS";

        case "RGMII":
        case "RGMII1":
        case "RGMII2":
        case "RMII":
        case "RMII1":
        case "RMII2":
        case "MII":
        case "MII1":
        case "MII2":
        case "MDIO":
            return "CPSW";

        case "MMC":
            return "MMCSD";

        case "CAM":
            return "VPFE";

        case "SPI":
            return "MCSPI";

        default:
            return assignment.interfaceName;
    }
};

var getPeripheralNum = function( assignment ) {
    // MII1_PRUSS is currently an exception.  We probably should have a
    // MII_PRUSS interface with two peripherals.

    if( assignment.interfaceName == "MII1_PRUSS" ) {
        return 1;
    }

    // Otherwise, look at the last character in the peripheral name.  If it's a
    // number, then we use that.  Otherwise, use 0

    var lastChar = parseInt( assignment.peripheral.name[ assignment.peripheral.name.length - 1 ] );
    if( isNaN( lastChar ) ) {
        return 0;
    }
    return lastChar;
};

var getMappedPeripheral = function( assignment ) {

    switch( assignment.interfaceName ) {
        case "RGMII":
        case "RGMII1":
        case "RGMII2":
        case "RMII":
        case "RMII1":
        case "RMII2":
        case "MII":
        case "MII1":
        case "MII2":
        case "MDIO":
            return getMappedInterface( assignment ) + "0";

        default:
            return getMappedInterface( assignment ) + getPeripheralNum( assignment );
    }
};

var getPeripheralInstNum = function( assignment ) {
    // MII1_PRUSS is currently an exception.  We probably should have a
    // MII_PRUSS interface with two peripherals.

    if( assignment.interfaceName == "MII1_PRUSS" ) {
        return 1;
    }

    var optionalParameters = getMappedPeripheral(assignment);

    // Otherwise, look at the last character in the peripheral name.  If it's a
    // number, then we use that.  Otherwise, use 0
    if(optionalParameters == assignment.interfaceName)
    {
        var lastChar = parseInt( assignment.peripheral.name[ assignment.peripheral.name.length - 1 ] );
    }
    else
    {
        var lastChar = parseInt( optionalParameters[ optionalParameters.length - 1 ] );
    }
    if( isNaN( lastChar ) ) {
        return 0;
    }
    return lastChar;
};

var OPT_PARAM = function( assignment ) {

    // If the peripheral is one of the following, then use the macro specified

    var optionalParameters = {
        PRU1_PRUSS1 : "PINMUX_SS_PRU_ICSS_PRU1",
        PRU0_PRUSS1 : "PINMUX_SS_PRU_ICSS_PRU0",
        eCAP0_PRUSS1 : "PINMUX_SS_PRU_ICSS_ECAP0",
        UART0_PRUSS1 : "PINMUX_SS_PRU_ICSS_UART0",
        MII0_PRUSS1 : "PINMUX_SS_PRU_ICSS_MII0",
        MII1_PRUSS1 : "PINMUX_SS_PRU_ICSS_MII1",
        ECAT_PRUSS1 : "PINMUX_SS_PRU_ICSS_ECAT",
        MDIO_PRUSS1 : "PINMUX_SS_PRU_ICSS_MDIO",
        eCAP0 : "PINMUX_SS_PWMSS_ECAP0",
        eCAP1 : "PINMUX_SS_PWMSS_ECAP1",
        eCAP2 : "PINMUX_SS_PWMSS_ECAP2",
        eQEP0 : "PINMUX_SS_PWMSS_EQEP0",
        eQEP1 : "PINMUX_SS_PWMSS_EQEP1",
        eQEP2 : "PINMUX_SS_PWMSS_EQEP2",
        eHRPWM0 : "PINMUX_SS_PWMSS_EHRPWM0",
        eHRPWM1 : "PINMUX_SS_PWMSS_EHRPWM1",
        eHRPWM2 : "PINMUX_SS_PWMSS_EHRPWM2",
        eHRPWM3 : "PINMUX_SS_PWMSS_EHRPWM3",
        eHRPWM4 : "PINMUX_SS_PWMSS_EHRPWM4",
        eHRPWM5 : "PINMUX_SS_PWMSS_EHRPWM5"
    }

    if( assignment.peripheral.name in optionalParameters ) {
        return "(uint16_t)" + optionalParameters[ assignment.peripheral.name ];
    }

    // Sanity check that we got every PRU_ICSS and PWMSS at this point

    if( assignment.interfaceName !== getMappedInterface( assignment )
        &&  "CPSW" !== getMappedInterface( assignment )
        &&  "VPFE" !== getMappedInterface( assignment )
        &&  "MMCSD" !== getMappedInterface( assignment )
        &&  "MCSPI" !== getMappedInterface( assignment )
    ) {
        console.log( "Template failed to find an optional parameter for " + assignment.peripheral.name );
        throw new Error( "Template failed to find an optional parameter for " + assignment.peripheral.name );
    }

    // If this is a GPIO pin, extract the pin number and use that

    if( "GPIO" === assignment.interfaceName ) {
        return /\[([0-9]+)\]/.exec( assignment.peripheralPin.name )[1];
    }

    // For everything else, return 0

    return 0;
}

var PinOptions = function( assignment ) {
    var options = [];
    var notOptions = [];

    var addOption = function( option ) {
        if( option[0] === '~' ) {
            notOptions.push( option );
        } else {
            options.push( option );
        }
    };

    var IS_PULL_ENABLED = function() {
        if( assignment.pu || assignment.pd ) {
            return "~PIN_PULL_UD_EN";
        }
        return "PIN_PULL_UD_EN";
    };

    var PULL_TYPE = function() {
        if( assignment.pu ) {
            return "PIN_PULL_TYPE_SEL";
        }
        return "~PIN_PULL_TYPE_SEL";
    };

    var IS_RX_ACTIVE = function() {
        if( assignment.rx ) {
            return "PIN_RX_ACTIVE";
        }
        return "~PIN_RX_ACTIVE";
    };

    addOption( IS_PULL_ENABLED() );
    addOption( PULL_TYPE() );
    addOption( IS_RX_ACTIVE() );

    var formatOptions = function( optionsList, operator ) {
    if(optionsList.length == 0) {
        if (operator === " | ") {
            var result = "(0x38";
        }
        if (operator === " & ") {
            var result = "(0xFF";
        }
    }
    else {
        var result = "(";
    }
        for( var i = 0; i < optionsList.length; ++i ) {
            result += optionsList[i];
            if( i != optionsList.length - 1 ) {
                result += operator;
            }
        }
        result += ")";
        return result;
    };

    this.getOptions = function() {
        return formatOptions( options, " | " );
    }

    this.getNotOptions = function() {

        return formatOptions( notOptions, " & " );
    }
}

// First, we need to sort all pin assigments into their mapped interfaces/
// peripherals.  This mapping isn't what pinmux knows, so we have to do it

var mappedAssignments = {};
for( var i = 0; i < assignments.length; ++i ) {
	if ( assignments[i].devicePin.controlRegisterOffset === "NOT FOUND" ) {
		// do nothing with assignments that have no pad config register
	} else {
		var interfaceName = getMappedInterface( assignments[i] );
		var peripheralName = getMappedPeripheral( assignments[i] );
		mappedAssignments[ interfaceName ] = mappedAssignments[ interfaceName ] || {};
		mappedAssignments[ interfaceName ][ peripheralName ] = mappedAssignments[ interfaceName ][ peripheralName ] || [];
		mappedAssignments[ interfaceName ][ peripheralName ].push( assignments[i] );
	}
}

 _.each( mappedAssignments, function( peripherals, interfaceName ) {
;
__p += '#ifndef BUILDCFG_MOD_' +
((__t = (interfaceName.toUpperCase())) == null ? '' : __t) +
'\n#define BUILDCFG_MOD_' +
((__t = (interfaceName.toUpperCase())) == null ? '' : __t) +
'\n#endif /* BUILDCFG_MOD_' +
((__t = (interfaceName.toUpperCase())) == null ? '' : __t) +
' */\n\n';
 } );
;
__p += '\n';
 _.each( mappedAssignments, function( peripherals, interfaceName ) {
;
__p += '#if defined(BUILDCFG_MOD_' +
((__t = (interfaceName.toUpperCase())) == null ? '' : __t) +
')\n\n';
   _.each( peripherals, function( pins, peripheralName ) {
;
__p += 'static pinmuxPerCfg_t g' +
((__t = (capitalizeFirstLetterOnly( peripheralName ))) == null ? '' : __t) +
'PinCfg[] =\n{\n';

    var printSMA2 = 0;
    var enumStatements = [];
        for( var i = 0; i < pins.length; ++i ) {
            if( undefined == pins[i].devicePin.controlRegisterOffset || "NOT FOUND" == pins[i].devicePin.controlRegisterOffset ) {
            }
            else {
                var pinMuxMode = pins[i].muxMode;
                if (8 == pinMuxMode) {
                    printSMA2 = 1;
                    pinMuxMode = 3;
                } else if (9 == pinMuxMode) {
                    printSMA2 = 0;
                    pinMuxMode = 3;
                }
                var pinOptions = new PinOptions( pins[i] );
    enumStatements.push({line1 : "{",
        line2 : "   /* " + pins[i].requirementName + " -> " + pins[i].peripheralPin.name + " -> " + pins[i].devicePin.ball + " */",
        line3 : "   PIN_" + pins[i].devicePin.designSignalName.toUpperCase() + ", " + OPT_PARAM( pins[i] ) + ", \\",
        line4 : "   ( \\",
        line5 : "       PIN_MODE(" + pinMuxMode + ") | \\",
        line6 : "       (" + pinOptions.getOptions() + " & " + pinOptions.getNotOptions() + ") \\",
        line7 : "   ) \\",
        line8 : "},"});
            }
       }
   for( var i = 0; i < enumStatements.length; ++i ) {
;
__p += '    ' +
((__t = (enumStatements[i].line1)) == null ? '' : __t) +
'\n    ' +
((__t = (enumStatements[i].line2)) == null ? '' : __t) +
'\n    ' +
((__t = (enumStatements[i].line3)) == null ? '' : __t) +
'\n    ' +
((__t = (enumStatements[i].line4)) == null ? '' : __t) +
'\n    ' +
((__t = (enumStatements[i].line5)) == null ? '' : __t) +
'\n    ' +
((__t = (enumStatements[i].line6)) == null ? '' : __t) +
'\n    ' +
((__t = (enumStatements[i].line7)) == null ? '' : __t) +
'\n    ' +
((__t = (enumStatements[i].line8)) == null ? '' : __t) +
'\n';
   }
   if (1 == printSMA2) {
;
__p += '    {SMA2_REGISTER,0,0x1U},\n';
   }
;
__p += '    {PINMUX_INVALID_PIN}\n};\n\n';
   } );
;
__p += 'static pinmuxModuleCfg_t g' +
((__t = (capitalizeFirstLetterOnly( interfaceName ))) == null ? '' : __t) +
'PinCfg[] =\n{\n';
   _.each( peripherals, function( pins, peripheralName ) {
;
__p += '    {' +
((__t = (getPeripheralInstNum( pins[0] ))) == null ? '' : __t) +
', TRUE, g' +
((__t = (capitalizeFirstLetterOnly( peripheralName ))) == null ? '' : __t) +
'PinCfg},\n';
   } );
;
__p += '    {CHIPDB_INVALID_INSTANCE_NUM}\n};\n\n#endif /* if defined(BUILDCFG_MOD_' +
((__t = (interfaceName.toUpperCase())) == null ? '' : __t) +
') */\n\n';
 } );
;
__p += '\npinmuxBoardCfg_t gAMIC110PinmuxData[] =\n{\n';
 _.each( mappedAssignments, function( iface, interfaceName ) {
;
__p += '#if defined(BUILDCFG_MOD_' +
((__t = (interfaceName.toUpperCase())) == null ? '' : __t) +
')\n    {CHIPDB_MOD_ID_' +
((__t = (interfaceName.toUpperCase())) == null ? '' : __t) +
', g' +
((__t = (capitalizeFirstLetterOnly(interfaceName))) == null ? '' : __t) +
'PinCfg},\n#endif /* if defined(BUILDCFG_MOD_' +
((__t = (interfaceName.toUpperCase())) == null ? '' : __t) +
') */\n';
 } );
;
__p += '    {CHIPDB_MOD_ID_INVALID}\n};\n';
return __p
}; });